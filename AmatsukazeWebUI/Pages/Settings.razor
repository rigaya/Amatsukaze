@page "/settings"
@using System
@using System.Text.Json
@using System.Text.Json.Nodes
@using Amatsukaze.Shared
@inject IAmatsukazeApi Api

<h3>基本設定</h3>

<div class="settings-header">
    <button class="btn btn-primary" @onclick="ApplyAsync" disabled="@(_loading || _setting == null)">適用</button>
    <button class="btn btn-secondary" @onclick="ReloadAsync" disabled="@_loading">更新</button>
    <span class="settings-header-note">「適用」で反映。「更新」を押すと編集中の設定が失われるので注意</span>
</div>

@if (_loading)
{
    <p>Loading...</p>
}
else if (!string.IsNullOrEmpty(_error))
{
    <p style="color: red;">@_error</p>
}
else if (_setting == null)
{
    <p>No data.</p>
}
else
{
    <div class="settings-page">
    <h4>一般</h4>
    <table class="table">
        <tr>
            <th>一時フォルダ (重要)</th>
            <td>
                <PathSuggestInput Value="@GetStringValue(WorkPathField)"
                                  ValueChanged="@(v => OnStringValueChanged(v, WorkPathField))"
                                  AllowFiles="false"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="0"
                                  Disabled="@_loading" />
            </td>
        </tr>
        @foreach (var item in _generalBoolFields)
        {
            if (IsServerLinux && item.Field == SupressSleepField)
            {
                continue;
            }
            <tr class="settings-check-row">
                <td colspan="2">
                    <label class="settings-check">
                        <input type="checkbox" checked="@GetBoolValue(item.Field)" @onchange="@(e => OnBoolChange(e, item.Field))" />
                        @item.Label
                    </label>
                </td>
            </tr>
        }
    </table>

    <hr class="settings-sep" />
    <h4>パス</h4>
    <table class="table">
        @foreach (var item in _pathFields)
        {
            if (IsServerLinux && IsWindowsOnlyPath(item.Field))
            {
                continue;
            }
            <tr>
                <th>@item.Label</th>
                <td>
                    <PathSuggestInput Value="@GetStringValue(item.Field)"
                                      ValueChanged="@(v => OnStringValueChanged(v, item.Field))"
                                      Extensions="@GetPathExtensions(item.Field, item.Extensions)"
                                      AllowFiles="@item.AllowFiles"
                                      AllowDirs="@item.AllowDirs"
                                      MaxDirs="10"
                                      MaxFiles="20"
                                      Disabled="@_loading" />
                </td>
            </tr>
        }
    </table>

    <hr class="settings-sep" />
    <h4>動作</h4>
    <table class="table">
        @foreach (var item in _behaviorBoolFields)
        {
            <tr class="settings-check-row">
                <td colspan="2">
                    <label class="settings-check">
                        <input type="checkbox" checked="@GetBoolValue(item.Field)" @onchange="@(e => OnBoolChange(e, item.Field))" />
                        @item.Label
                    </label>
                </td>
            </tr>
        }
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(DeleteOldLogsField)" @onchange="@(e => OnBoolChange(e, DeleteOldLogsField))" />
                    古いログを削除
                </label>
                <span style="margin-left: 12px;">日数</span>
                <input type="number" min="0" step="1" style="width: 60px; margin-left: 6px;" value="@GetIntValue(DeleteOldLogsDaysField)" @oninput="@(e => OnIntInput(e, DeleteOldLogsDaysField))" disabled="@(GetBoolValue(DeleteOldLogsField) == false)" />
            </td>
        </tr>
    </table>

    <hr class="settings-sep" />
    <h4>スケジューリング</h4>
    <table class="table">
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(SchedulingEnabledField)" @onchange="@(e => OnBoolChange(e, SchedulingEnabledField))" />
                    リソーススケジューリングを有効にする
                </label>
            </td>
        </tr>
        <tr>
            <th>GPU数</th>
            <td><input type="number" min="1" max="16" step="1" style="width: 60px;" value="@GetIntValue(NumGpuField)" @oninput="@(e => OnIntInput(e, NumGpuField))" disabled="@(GetBoolValue(SchedulingEnabledField) == false)" /></td>
        </tr>
    </table>

    <hr class="settings-sep" />
    <h4>並列・優先度</h4>
    <table class="table">
        <tr>
            <th>並列数</th>
            <td>
                <div class="settings-range">
                    <input type="range" min="1" max="@MaxParallel" step="1" value="@GetIntValue(NumParallelField)" @oninput="@(e => OnIntInput(e, NumParallelField))" />
                    <span class="settings-range-value">@GetIntValue(NumParallelField)</span>
                </div>
            </td>
        </tr>
        <tr>
            <th>ロゴ解析並列数</th>
            <td>
                <div class="settings-range">
                    <label class="settings-check" style="margin-right: 10px;">
                        <input type="checkbox" checked="@IsNumParallelLogoAuto" @onchange="OnLogoParallelAutoChange" />
                        自動
                    </label>
                    @if (!IsNumParallelLogoAuto)
                    {
                        <input type="range" min="1" max="@MaxLogoParallel" step="1" value="@GetIntValue(NumParallelLogoField)" @oninput="@(e => OnLogoParallelInput(e))" />
                        <span class="settings-range-value">@GetIntValue(NumParallelLogoField)</span>
                    }
                </div>
            </td>
        </tr>
        <tr>
            <th>プロセス優先度</th>
            <td>
                <select @onchange="@(e => OnIntSelect(e, ProcessPriorityField))">
                    @for (var i = 0; i < _processPriorityOptions.Length; i++)
                    {
                        <option value="@i" selected="@(i == GetIntValue(ProcessPriorityField))">@_processPriorityOptions[i]</option>
                    }
                </select>
            </td>
        </tr>
        <tr>
            <th>アフィニティ設定</th>
            <td>
                <select @onchange="@(e => OnIntSelect(e, AffinitySettingField))">
                    @for (var i = 0; i < _affinityOptions.Length; i++)
                    {
                        <option value="@i" selected="@(i == GetIntValue(AffinitySettingField))">@_affinityOptions[i]</option>
                    }
                </select>
            </td>
        </tr>
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(ExclusiveBatExecField)" @onchange="@(e => OnBoolChange(e, ExclusiveBatExecField))" />
                    バッチ同時実行を抑止
                </label>
            </td>
        </tr>
    </table>

    <hr class="settings-sep" />
    <h4>終了処理</h4>
    <table class="table">
        @if (!IsServerLinux)
        {
            <tr class="settings-check-row">
                <td colspan="2">
                    <label class="settings-check">
                        <input type="checkbox" checked="@GetBoolValue(EnableShutdownField)" @onchange="@(e => OnBoolChange(e, EnableShutdownField))" />
                        エンコード後シャットダウンの選択肢を有効化
                    </label>
                </td>
            </tr>
            <tr class="settings-check-row">
                <td colspan="2">
                    <label class="settings-check">
                        <input type="checkbox" checked="@GetBoolValue(NoActionExeField)" @onchange="@(e => OnBoolChange(e, NoActionExeField))" />
                        指定プロセス実行中にスリープ・休止・シャットダウンを行わない
                    </label>
                </td>
            </tr>
        }
        @if (!IsServerLinux && GetBoolValue(NoActionExeField))
        {
            <tr>
                <th>対象プロセスの実行ファイル名</th>
                <td>
                    <input style="width: 220px;" value="@_noActionExeName" @oninput="@(e => _noActionExeName = e.Value?.ToString() ?? "")" />
                    <button class="btn btn-sm btn-secondary" style="margin-left: 6px;" @onclick="AddNoActionExe">追加</button>
                </td>
            </tr>
            <tr>
                <th>登録済み</th>
                <td>
                    <select size="5" style="width: 220px;" @onchange="OnNoActionExeSelected">
                        @for (var i = 0; i < _noActionExeList.Count; i++)
                        {
                            <option value="@i" selected="@(i == _selectedNoActionExeIndex)">
                                @_noActionExeList[i]
                            </option>
                        }
                    </select>
                    <button class="btn btn-sm btn-secondary" style="margin-left: 6px;" @onclick="RemoveNoActionExe" disabled="@(_selectedNoActionExeIndex < 0)">削除</button>
                </td>
            </tr>
        }
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(ExecuteBatchAfterQueueField)" @onchange="@(e => OnBoolChange(e, ExecuteBatchAfterQueueField))" />
                    キュー完了後バッチを実行
                </label>
            </td>
        </tr>
        @if (GetBoolValue(ExecuteBatchAfterQueueField))
        {
            <tr>
                <th>バッチファイルのパス</th>
                <td>
                    <select style="width: 320px;" @onchange="OnQueueFinishBatSelected">
                        <option value="">(未選択)</option>
                        @foreach (var item in GetQueueFinishBatOptions())
                        {
                            <option value="@item" selected="@(item == GetStringValue(BatchFileAfterQueuePathField))">@item</option>
                        }
                    </select>
                </td>
            </tr>
        }
    </table>

    <hr class="settings-sep" />
    <h4>X265 VFR Time Factor</h4>
    <table class="table">
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@IsX265VfrDefault" @onchange="OnX265VfrDefaultChange" />
                    デフォルト値を使う
                </label>
            </td>
        </tr>
        <tr>
            <th>値</th>
            <td><input type="number" min="0" max="1" step="0.01" style="width: 80px;" value="@GetDoubleValue(X265VfrFactorField)" @oninput="@(e => OnDoubleInput(e, X265VfrFactorField))" disabled="@IsX265VfrDefault" /></td>
        </tr>
    </table>

    <hr class="settings-sep" />
    <h4>実行時間帯</h4>
    <table class="table">
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(EnableRunHoursField)" @onchange="@(e => OnBoolChange(e, EnableRunHoursField))" />
                    有効
                </label>
            </td>
        </tr>
        <tr class="settings-check-row">
            <td colspan="2">
                <label class="settings-check">
                    <input type="checkbox" checked="@GetBoolValue(RunHoursSuspendField)" @onchange="@(e => OnBoolChange(e, RunHoursSuspendField))" disabled="@(GetBoolValue(EnableRunHoursField) == false)" />
                    停止中はエンコーダを停止する
                </label>
            </td>
        </tr>
        <tr>
            <th>時間帯</th>
            <td>
                <div class="run-hours-grid">
                    @for (var i = 0; i < 24; i++)
                    {
                        var hour = i;
                        var isOn = GetRunHour(hour);
                        var cellStyle = isOn
                            ? "background: color-mix(in srgb, var(--success) 25%, var(--bg-surface)); border-color: color-mix(in srgb, var(--success) 70%, var(--border));"
                            : "background: color-mix(in srgb, var(--danger) 15%, var(--bg-surface)); border-color: var(--border);";
                        var debugTitle = $"runhour {hour} = {isOn}";
                        <div role="button"
                             tabindex="0"
                             class="run-hour-cell @(isOn ? "is-on" : "")"
                             style="@cellStyle"
                             title="@debugTitle"
                             @onclick="() => ToggleRunHour(hour)">
                            <span>@hour</span>
                        </div>
                    }
                </div>
            </td>
        </tr>
    </table>
    </div>
}

@code {
    private readonly (string Label, string Field)[] _generalBoolFields = new[]
    {
        ("開始時に一時フォルダを空にする", "ClearWorkDirOnStart"),
        ("エンコード中はスリープしないようにする", "SupressSleep"),
        ("Amatsukaze起動時にアクティブなアイテムがあるときはキューを停止する", "PauseOnStarted")
    };

    private readonly (string Label, string Field)[] _behaviorBoolFields = new[]
    {
        ("ロゴ設定がない場合はエラー扱いにする", "LogoPendAsError"),
        ("フィルタグラフを出力する", "DumpFilter"),
        ("ログの先頭に時刻を表示する", "PrintTimePrefix"),
        ("CM解析のみ実行時にtrimn.avsを入力ディレクトリにコピーする", "CopyTrimAVS")
    };

    private readonly (string Label, string Field, string? Extensions, bool AllowFiles, bool AllowDirs)[] _pathFields = new[]
    {
        ("AmatsukazeCLI", "AmatsukazePath", (string?)".exe", true, true),
        ("x264", "X264Path", (string?)".exe", true, true),
        ("x265", "X265Path", (string?)".exe", true, true),
        ("SvtAv1EncApp", "SVTAV1Path", (string?)".exe", true, true),
        ("QSVEncC", "QSVEncPath", (string?)".exe", true, true),
        ("NVEncC", "NVEncPath", (string?)".exe", true, true),
        ("VCEEncC", "VCEEncPath", (string?)".exe", true, true),
        ("L-SMASH Muxer", "MuxerPath", (string?)".exe", true, true),
        ("mkvmerge", "MKVMergePath", (string?)".exe", true, true),
        ("MP4Box", "MP4BoxPath", (string?)".exe", true, true),
        ("TimelineEditor", "TimelineEditorPath", (string?)".exe", true, true),
        ("ChapterExe", "ChapterExePath", (string?)".exe", true, true),
        ("JoinLogoScp", "JoinLogoScpPath", (string?)".txt", true, true),
        ("tsreadex", "TsReadExPath", (string?)".exe", true, true),
        ("b24tovtt", "B24ToVttPath", (string?)".exe", true, true),
        ("psisiarc", "PsisiarcPath", (string?)".exe", true, true),
        ("Whisper", "WhisperPath", (string?)".exe", true, true),
        ("NicoConvASS", "NicoConvASSPath", (string?)".exe", true, true),
        ("tsreplace", "TsReplacePath", (string?)".exe", true, true),
        ("tsMuxeR", "TsMuxeRPath", (string?)".exe", true, true),
        ("SCRename.vbs/py", "SCRenamePath", (string?)".vbs;.py", true, true),
        ("AutoVfr.exe", "AutoVfrPath", (string?)".exe", true, true),
        ("neroAacEnc", "NeroAacEncPath", (string?)".exe", true, true),
        ("qaac", "QaacPath", (string?)".exe", true, true),
        ("fdkaac", "FdkaacPath", (string?)".exe", true, true),
        ("opusenc", "OpusEncPath", (string?)".exe", true, true)
    };

    private const string WorkPathField = "WorkPath";
    private const string AlwaysShowDiskField = "AlwaysShowDisk";
    private const string DeleteOldLogsField = "DeleteOldLogs";
    private const string DeleteOldLogsDaysField = "DeleteOldLogsDays";
    private const string SchedulingEnabledField = "SchedulingEnabled";
    private const string NumGpuField = "NumGPU";
    private const string NumParallelField = "NumParallel";
    private const string NumParallelLogoField = "NumParallelLogoAnalysis";
    private const string ProcessPriorityField = "ProcessPriority";
    private const string AffinitySettingField = "AffinitySetting";
    private const string ExclusiveBatExecField = "ExclusiveBatExec";
    private const string EnableX265VfrField = "EnableX265VFRTimeFactor";
    private const string X265VfrFactorField = "X265VFRTimeFactor";
    private const string EnableRunHoursField = "EnableRunHours";
    private const string RunHoursSuspendField = "RunHoursSuspendEncoders";
    private const string EnableShutdownField = "EnableShutdownAction";
    private const string NoActionExeField = "NoActionExe";
    private const string ExecuteBatchAfterQueueField = "ExecuteBatchAfterQueue";
    private const string BatchFileAfterQueuePathField = "BatchFileAfterQueuePath";
    private const string SupressSleepField = "SupressSleep";
    private static readonly string[] _processPriorityOptions = new[] { "通常", "通常以下", "低" };
    private static readonly string[] _affinityOptions = new[] { "なし", "コア", "L2", "L3", "NUMA", "Group" };
    private string? _error;
    private bool _loading = true;
    private JsonObject? _setting;
    private readonly Dictionary<string, string> _stringValues = new();
    private readonly Dictionary<string, bool> _boolValues = new();
    private readonly Dictionary<string, int> _intValues = new();
    private readonly Dictionary<string, double> _doubleValues = new();
    private bool[] _runHours = new bool[24];
    private readonly List<string> _queueFinishBatFiles = new();
    private readonly List<string> _noActionExeList = new();
    private string _noActionExeName = "";
    private int _selectedNoActionExeIndex = -1;
    private int _lastLogoParallelManual = 1;
    private bool _isServerLinux;
    private int _serverLogicalProcessorCount = 128;
    private int _reloadVersion;

    protected override Task OnInitializedAsync() => ReloadAsync();

    private async Task ReloadAsync()
    {
        _loading = true;
        _error = null;
        _setting = null;
        _stringValues.Clear();
        _boolValues.Clear();
        _intValues.Clear();
        _doubleValues.Clear();
        _runHours = new bool[24];
        _queueFinishBatFiles.Clear();
        _noActionExeList.Clear();
        _noActionExeName = "";
        _selectedNoActionExeIndex = -1;
        _serverLogicalProcessorCount = 128;
        var reloadVersion = ++_reloadVersion;

        var settingTask = Api.GetSettingAsync();
        var queueFinishTask = Api.GetQueueFinishBatFilesAsync();
        var profileOptionsTask = Api.GetProfileOptionsAsync();

        await Task.WhenAll(settingTask, queueFinishTask, profileOptionsTask);

        var settingRes = await settingTask;
        var queueFinishRes = await queueFinishTask;
        var profileOptionsRes = await profileOptionsTask;

        if (profileOptionsRes.Ok && profileOptionsRes.Data != null)
        {
            _isServerLinux = profileOptionsRes.Data.IsServerLinux;
        }
        else
        {
            _isServerLinux = false;
        }

        if (!settingRes.Ok)
        {
            _error = settingRes.Error ?? "Failed to load settings.";
        }
        else if (settingRes.Data.ValueKind != JsonValueKind.Undefined && settingRes.Data.ValueKind != JsonValueKind.Null)
        {
            _setting = JsonNode.Parse(settingRes.Data.GetRawText()) as JsonObject;
            if (_setting != null)
            {
                InitializeFieldValues();
            }
        }

        if (queueFinishRes.Ok && queueFinishRes.Data != null)
        {
            _queueFinishBatFiles.AddRange(queueFinishRes.Data);
        }
        else if (!queueFinishRes.Ok && string.IsNullOrEmpty(_error))
        {
            _error = queueFinishRes.Error ?? "Failed to load queue finish bat files.";
        }

        _loading = false;
        _ = LoadSystemLimitsAsync(reloadVersion);
    }

    private async Task LoadSystemLimitsAsync(int reloadVersion)
    {
        var systemRes = await Api.GetSystemAsync();
        if (reloadVersion != _reloadVersion)
        {
            return;
        }
        if (!systemRes.Ok || systemRes.Data?.ServerInfo == null)
        {
            return;
        }
        var logical = systemRes.Data.ServerInfo.LogicalProcessorCount;
        if (logical <= 0)
        {
            return;
        }

        _serverLogicalProcessorCount = logical;
        if (_intValues.TryGetValue(NumParallelField, out var numParallel))
        {
            _intValues[NumParallelField] = NormalizeIntValue(NumParallelField, numParallel);
        }
        if (_intValues.TryGetValue(NumParallelLogoField, out var numLogoParallel))
        {
            var normalized = NormalizeIntValue(NumParallelLogoField, numLogoParallel);
            _intValues[NumParallelLogoField] = normalized;
            if (normalized > 0)
            {
                _lastLogoParallelManual = normalized;
            }
        }
        await InvokeAsync(StateHasChanged);
    }

    private void InitializeFieldValues()
    {
        if (_setting == null)
        {
            return;
        }
        _stringValues[WorkPathField] = GetString(WorkPathField);
        _stringValues[AlwaysShowDiskField] = GetString(AlwaysShowDiskField);
        _stringValues[BatchFileAfterQueuePathField] = GetString(BatchFileAfterQueuePathField);
        foreach (var item in _pathFields)
        {
            _stringValues[item.Field] = GetString(item.Field);
        }
        foreach (var item in _generalBoolFields)
        {
            _boolValues[item.Field] = GetBool(item.Field);
        }
        foreach (var item in _behaviorBoolFields)
        {
            _boolValues[item.Field] = GetBool(item.Field);
        }
        _boolValues[DeleteOldLogsField] = GetBool(DeleteOldLogsField);
        _boolValues[SchedulingEnabledField] = GetBool(SchedulingEnabledField);
        _boolValues[EnableX265VfrField] = GetBool(EnableX265VfrField);
        _boolValues[EnableRunHoursField] = GetBool(EnableRunHoursField);
        _boolValues[RunHoursSuspendField] = GetBool(RunHoursSuspendField);
        _boolValues[EnableShutdownField] = GetBool(EnableShutdownField);
        _boolValues[NoActionExeField] = GetBool(NoActionExeField);
        _boolValues[ExecuteBatchAfterQueueField] = GetBool(ExecuteBatchAfterQueueField);
        _boolValues[ExclusiveBatExecField] = GetBool(ExclusiveBatExecField);

        _intValues[DeleteOldLogsDaysField] = NormalizeIntValue(DeleteOldLogsDaysField, GetInt(DeleteOldLogsDaysField));
        _intValues[NumGpuField] = NormalizeIntValue(NumGpuField, GetInt(NumGpuField));
        _intValues[NumParallelField] = NormalizeIntValue(NumParallelField, GetInt(NumParallelField));
        _intValues[NumParallelLogoField] = NormalizeIntValue(NumParallelLogoField, GetInt(NumParallelLogoField));
        _intValues[ProcessPriorityField] = NormalizeIntValue(ProcessPriorityField, GetInt(ProcessPriorityField));
        _intValues[AffinitySettingField] = NormalizeIntValue(AffinitySettingField, GetInt(AffinitySettingField));
        _doubleValues[X265VfrFactorField] = NormalizeDoubleValue(X265VfrFactorField, GetDouble(X265VfrFactorField));
        _runHours = GetRunHoursArray();
        _noActionExeList.AddRange(GetStringList("NoActionExeList"));
        var logoParallel = _intValues.TryGetValue(NumParallelLogoField, out var currentLogoParallel) ? currentLogoParallel : 0;
        if (logoParallel > 0)
        {
            _lastLogoParallelManual = logoParallel;
        }
    }

    private async Task ApplyAsync()
    {
        if (_setting == null)
        {
            return;
        }
        _error = null;

        foreach (var kv in _stringValues)
        {
            SetSettingValue(kv.Key, kv.Value ?? "");
        }
        foreach (var kv in _boolValues)
        {
            SetSettingValue(kv.Key, kv.Value);
        }
        foreach (var kv in _intValues)
        {
            SetSettingValue(kv.Key, NormalizeIntValue(kv.Key, kv.Value));
        }
        foreach (var kv in _doubleValues)
        {
            SetSettingValue(kv.Key, NormalizeDoubleValue(kv.Key, kv.Value));
        }
        var runHoursArray = new JsonArray();
        foreach (var v in _runHours)
        {
            runHoursArray.Add(JsonValue.Create(v));
        }
        SetSettingValue("RunHours", runHoursArray);
        var noActionExeArray = new JsonArray();
        foreach (var item in _noActionExeList)
        {
            noActionExeArray.Add(JsonValue.Create(item));
        }
        SetSettingValue("NoActionExeList", noActionExeArray);

        var json = _setting.ToJsonString();
        using var doc = JsonDocument.Parse(json);
        var res = await Api.UpdateSettingAsync(doc.RootElement);
        if (!res.Ok)
        {
            _error = res.Error ?? "Failed to update settings.";
            return;
        }
        await ReloadAsync();
    }

    private string GetString(string name)
    {
        var node = GetSettingNode(name);
        if (node == null)
        {
            return "";
        }
        return node.GetValue<string>();
    }

    private List<string> GetStringList(string name)
    {
        var node = GetSettingNode(name);
        if (node is JsonArray arr)
        {
            var result = new List<string>();
            foreach (var item in arr)
            {
                var value = item?.GetValue<string>();
                if (!string.IsNullOrEmpty(value))
                {
                    result.Add(value);
                }
            }
            return result;
        }
        return new List<string>();
    }

    private bool GetBool(string name)
    {
        var node = GetSettingNode(name);
        if (node == null)
        {
            return false;
        }
        return node.GetValue<bool>();
    }

    private string GetStringValue(string name)
    {
        return _stringValues.TryGetValue(name, out var value) ? value : "";
    }

    private bool GetBoolValue(string name)
    {
        return _boolValues.TryGetValue(name, out var value) && value;
    }

    private void OnStringInput(ChangeEventArgs e, string name)
    {
        _stringValues[name] = e.Value?.ToString() ?? "";
    }

    private void OnStringValueChanged(string value, string name)
    {
        _stringValues[name] = value ?? "";
    }

    private void OnBoolChange(ChangeEventArgs e, string name)
    {
        _boolValues[name] = e.Value is bool b && b;
    }

    private void OnX265VfrDefaultChange(ChangeEventArgs e)
    {
        var useDefault = e.Value is bool b && b;
        _boolValues[EnableX265VfrField] = !useDefault;
    }

    private JsonNode? GetSettingNode(string name)
    {
        if (_setting == null)
        {
            return null;
        }
        if (_setting.TryGetPropertyValue(name, out var node) && node != null)
        {
            return node;
        }
        var camel = ToCamelCase(name);
        if (_setting.TryGetPropertyValue(camel, out var nodeCamel) && nodeCamel != null)
        {
            return nodeCamel;
        }
        foreach (var kv in _setting)
        {
            if (string.Equals(kv.Key, name, StringComparison.OrdinalIgnoreCase))
            {
                return kv.Value;
            }
        }
        return null;
    }

    private void SetSettingValue(string name, object value)
    {
        if (_setting == null)
        {
            return;
        }
        var key = name;
        if (!_setting.ContainsKey(key))
        {
            var camel = ToCamelCase(name);
            if (_setting.ContainsKey(camel))
            {
                key = camel;
            }
            else
            {
                foreach (var kv in _setting)
                {
                    if (string.Equals(kv.Key, name, StringComparison.OrdinalIgnoreCase))
                    {
                        key = kv.Key;
                        break;
                    }
                }
            }
        }
        if (value is JsonNode node)
        {
            _setting[key] = node;
            return;
        }
        _setting[key] = JsonValue.Create(value);
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }
        if (name.Length == 1)
        {
            return name.ToLowerInvariant();
        }
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string FormatList(List<string>? items)
    {
        return items == null || items.Count == 0 ? "-" : string.Join(", ", items);
    }

    private string? GetPathExtensions(string field, string? extensions)
    {
        if (string.IsNullOrWhiteSpace(extensions))
        {
            return null;
        }
        if (IsServerLinux && IsExeOnlyExtensions(extensions))
        {
            return null;
        }
        return extensions;
    }

    private static bool IsExeOnlyExtensions(string extensions)
    {
        var parts = extensions.Split(new[] { ';', ',', '|' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0)
        {
            return false;
        }
        foreach (var part in parts)
        {
            var trimmed = part.Trim();
            if (string.IsNullOrEmpty(trimmed))
            {
                continue;
            }
            var ext = trimmed.StartsWith(".") ? trimmed : "." + trimmed;
            if (!string.Equals(ext, ".exe", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
        }
        return true;
    }

    private void AddNoActionExe()
    {
        var value = _noActionExeName.Trim();
        if (string.IsNullOrEmpty(value))
        {
            return;
        }
        var exists = false;
        for (var i = 0; i < _noActionExeList.Count; i++)
        {
            if (string.Equals(_noActionExeList[i], value, StringComparison.OrdinalIgnoreCase))
            {
                exists = true;
                break;
            }
        }
        if (!exists)
        {
            _noActionExeList.Add(value);
        }
        _noActionExeName = "";
    }

    private void RemoveNoActionExe()
    {
        if (_selectedNoActionExeIndex < 0 || _selectedNoActionExeIndex >= _noActionExeList.Count)
        {
            return;
        }
        _noActionExeList.RemoveAt(_selectedNoActionExeIndex);
        _selectedNoActionExeIndex = -1;
    }

    private void OnNoActionExeSelected(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var index))
        {
            _selectedNoActionExeIndex = index;
        }
    }

    private List<string> GetQueueFinishBatOptions()
    {
        var options = new List<string>();
        options.AddRange(_queueFinishBatFiles);
        var current = GetStringValue(BatchFileAfterQueuePathField);
        if (!string.IsNullOrEmpty(current) && !options.Contains(current))
        {
            options.Insert(0, current);
        }
        return options;
    }

    private void OnQueueFinishBatSelected(ChangeEventArgs e)
    {
        _stringValues[BatchFileAfterQueuePathField] = e.Value?.ToString() ?? "";
    }

    private int GetInt(string name)
    {
        var node = GetSettingNode(name);
        if (node == null)
        {
            return 0;
        }
        return node.GetValue<int>();
    }

    private double GetDouble(string name)
    {
        var node = GetSettingNode(name);
        if (node == null)
        {
            return 0;
        }
        return node.GetValue<double>();
    }

    private int GetIntValue(string name)
    {
        return _intValues.TryGetValue(name, out var value) ? value : 0;
    }

    private double GetDoubleValue(string name)
    {
        return _doubleValues.TryGetValue(name, out var value) ? value : 0;
    }

    private void OnIntInput(ChangeEventArgs e, string name)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            _intValues[name] = NormalizeIntValue(name, value);
        }
    }

    private void OnIntSelect(ChangeEventArgs e, string name)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            _intValues[name] = NormalizeIntValue(name, value);
        }
    }

    private void OnLogoParallelInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            var normalized = NormalizeIntValue(NumParallelLogoField, value);
            _intValues[NumParallelLogoField] = normalized;
            if (normalized > 0)
            {
                _lastLogoParallelManual = normalized;
            }
        }
    }

    private void OnLogoParallelAutoChange(ChangeEventArgs e)
    {
        var enabled = e.Value is bool b && b;
        if (enabled)
        {
            _intValues[NumParallelLogoField] = 0;
        }
        else
        {
            var next = Math.Clamp(_lastLogoParallelManual, 1, MaxLogoParallel);
            _intValues[NumParallelLogoField] = next;
        }
    }

    private void OnDoubleInput(ChangeEventArgs e, string name)
    {
        if (double.TryParse(e.Value?.ToString(), out var value))
        {
            _doubleValues[name] = NormalizeDoubleValue(name, value);
        }
    }

    private int NormalizeIntValue(string name, int value)
    {
        if (name == DeleteOldLogsDaysField)
        {
            return Math.Max(0, value);
        }
        if (name == NumGpuField)
        {
            return Math.Clamp(value, 1, 16);
        }
        if (name == NumParallelField)
        {
            return Math.Clamp(value, 1, MaxParallel);
        }
        if (name == NumParallelLogoField)
        {
            if (value <= 0)
            {
                return 0;
            }
            var max = MaxLogoParallel;
            return Math.Clamp(value, 1, max);
        }
        if (name == ProcessPriorityField)
        {
            return Math.Clamp(value, 0, _processPriorityOptions.Length - 1);
        }
        if (name == AffinitySettingField)
        {
            return Math.Clamp(value, 0, _affinityOptions.Length - 1);
        }
        return value;
    }

    private double NormalizeDoubleValue(string name, double value)
    {
        if (name == X265VfrFactorField)
        {
            var clamped = Math.Clamp(value, 0.0, 1.0);
            return Math.Round(clamped, 2, MidpointRounding.AwayFromZero);
        }
        return value;
    }

    private bool[] GetRunHoursArray()
    {
        var node = GetSettingNode("RunHours");
        if (node is JsonArray arr && arr.Count == 24)
        {
            var result = new bool[24];
            for (var i = 0; i < 24; i++)
            {
                result[i] = arr[i]?.GetValue<bool>() == true;
            }
            return result;
        }
        return new bool[24];
    }

    private bool GetRunHour(int index)
    {
        if (index < 0 || index >= _runHours.Length)
        {
            return false;
        }
        return _runHours[index];
    }

    private void OnRunHourChange(ChangeEventArgs e, int index)
    {
        if (index < 0 || index >= _runHours.Length)
        {
            return;
        }
        _runHours[index] = e.Value is bool b && b;
    }

    private void ToggleRunHour(int index)
    {
        bool? before = null;
        if (index >= 0 && index < _runHours.Length)
        {
            before = _runHours[index];
        }
        global::System.Console.WriteLine($"[Settings] ToggleRunHour index={index} before={before}");
        if (index < 0 || index >= _runHours.Length)
        {
            return;
        }
        _runHours[index] = !_runHours[index];
        global::System.Console.WriteLine($"[Settings] ToggleRunHour index={index} after={_runHours[index]}");
        StateHasChanged();
    }

    private bool IsServerLinux => _isServerLinux;

    private bool IsX265VfrDefault => !GetBoolValue(EnableX265VfrField);

    private int MaxLogoParallel => _serverLogicalProcessorCount > 0 ? _serverLogicalProcessorCount : 1;

    private int MaxParallel => _serverLogicalProcessorCount > 0 ? _serverLogicalProcessorCount : 1;

    private bool IsNumParallelLogoAuto => GetIntValue(NumParallelLogoField) <= 0;

    private static bool IsWindowsOnlyPath(string field)
    {
        return field == "NicoConvASSPath"
            || field == "TsMuxeRPath"
            || field == "AutoVfrPath"
            || field == "NeroAacEncPath"
            || field == "QaacPath";
    }
}
