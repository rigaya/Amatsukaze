@page "/console/{TaskId:int}"
@using Amatsukaze.Shared
@inject IAmatsukazeApi Api
@inject IJSRuntime Js
@implements IAsyncDisposable

<h3>コンソール</h3>

@if (_loading)
{
    <p>Loading...</p>
}
else if (!string.IsNullOrEmpty(_error))
{
    <p style="color: red;">@_error</p>
}
else if (_view == null)
{
    <p>No data.</p>
}
else
{
    <table class="table console-meta">
        <tr>
            <th>Task</th>
            <td>@_view.Task?.TaskId</td>
        </tr>
        <tr>
            <th>ファイル名</th>
            <td>@_view.Task?.FileName</td>
        </tr>
        <tr>
            <th>サービス名</th>
            <td>@_view.Task?.ServiceName</td>
        </tr>
        <tr>
            <th>プロファイル</th>
            <td>@_view.Task?.ProfileName</td>
        </tr>
        <tr>
            <th>出力先</th>
            <td>@_view.Task?.OutDir</td>
        </tr>
    </table>
    <pre @ref="_logRef" class="console-log">@string.Join("\n", _view.Lines)</pre>
}

@code {
    [Parameter] public int TaskId { get; set; }

    private ConsoleTaskView? _view;
    private string? _error;
    private bool _loading = true;
    private long _version;
    private CancellationTokenSource? _pollCts;
    private Task? _pollTask;
    private bool _polling;
    private ElementReference _logRef;
    private bool _pendingScrollToBottom;

    private const double FollowThreshold = 20;

    protected override async Task OnParametersSetAsync()
    {
        await ReloadAsync();
    }

    private async Task ReloadAsync()
    {
        StopPolling();
        _loading = true;
        _error = null;
        _view = null;
        _version = 0;

        var res = await Api.GetConsoleTaskAsync(TaskId);
        if (!res.Ok)
        {
            _error = res.Error ?? "Failed to load console.";
        }
        else
        {
            _view = res.Data;
            if (_view != null)
            {
                _version = _view.Version;
                _pendingScrollToBottom = true;
                StartPolling();
            }
        }
        _loading = false;
    }

    private void StartPolling()
    {
        _pollCts?.Cancel();
        _pollCts = new CancellationTokenSource();
        var token = _pollCts.Token;
        _pollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private void StopPolling()
    {
        _pollCts?.Cancel();
    }

    private async Task PollOnceAsync()
    {
        if (_loading || _view == null || _polling)
        {
            return;
        }
        _polling = true;
        try
        {
            var follow = await ShouldFollowAsync();
            var res = await Api.GetConsoleTaskChangesAsync(TaskId, _version);
            if (!res.Ok)
            {
                _error = res.Error ?? "Failed to poll console.";
                return;
            }
            var data = res.Data;
            if (data == null)
            {
                return;
            }
            if (data.FullSyncRequired)
            {
                await ReloadAsync();
                return;
            }
            if (data.Changes.Count == 0)
            {
                _version = data.ToVersion;
                return;
            }
            ApplyConsoleChanges(data);
            if (follow)
            {
                _pendingScrollToBottom = true;
            }
            StateHasChanged();
        }
        finally
        {
            _polling = false;
        }
    }

    private void ApplyConsoleChanges(ConsoleTaskChangesView data)
    {
        if (_view == null)
        {
            return;
        }
        _version = data.ToVersion;
        var lines = _view.Lines;
        foreach (var change in data.Changes)
        {
            switch (change.Type)
            {
                case ConsoleChangeType.Add:
                    if (!string.IsNullOrEmpty(change.Line))
                    {
                        lines.Add(change.Line);
                    }
                    break;
                case ConsoleChangeType.Replace:
                    if (lines.Count == 0)
                    {
                        if (!string.IsNullOrEmpty(change.Line))
                        {
                            lines.Add(change.Line);
                        }
                    }
                    else
                    {
                        lines[lines.Count - 1] = change.Line ?? string.Empty;
                    }
                    break;
                case ConsoleChangeType.Clear:
                    lines.Clear();
                    break;
            }
        }
        TrimLines(lines);
    }

    private static void TrimLines(List<string> lines)
    {
        if (lines.Count <= ConsoleConstants.MaxConsoleLines)
        {
            return;
        }
        var trim = Math.Max(ConsoleConstants.ConsoleTrimLines, lines.Count - ConsoleConstants.MaxConsoleLines);
        trim = Math.Min(trim, lines.Count);
        lines.RemoveRange(0, trim);
    }

    private async Task<bool> ShouldFollowAsync()
    {
        try
        {
            var info = await Js.InvokeAsync<ScrollInfo>("amatsukazeUi.getScrollInfo", _logRef);
            return info.Remaining <= FollowThreshold;
        }
        catch
        {
            return true;
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            var info = await Js.InvokeAsync<ScrollInfo>("amatsukazeUi.getScrollInfo", _logRef);
            await Js.InvokeVoidAsync("amatsukazeUi.setScrollTop", _logRef, info.ScrollHeight);
        }
        catch
        {
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingScrollToBottom)
        {
            _pendingScrollToBottom = false;
            await ScrollToBottomAsync();
        }
    }

    public async ValueTask DisposeAsync()
    {
        _pollCts?.Cancel();
        if (_pollTask != null)
        {
            try
            {
                await _pollTask;
            }
            catch
            {
            }
        }
    }

    private sealed class ScrollInfo
    {
        public double ScrollTop { get; set; }
        public double ScrollHeight { get; set; }
        public double ClientHeight { get; set; }
        public double Remaining { get; set; }
    }
}
