@page "/queue"
@using Amatsukaze.Shared
@using System.Text.Json
@using System.Threading
@using System.IO
@inject IAmatsukazeApi Api
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IAsyncDisposable

<h3>Queue</h3>

<p>
    <button class="btn btn-primary" @onclick="ReloadAsync" disabled="@_loading">Reload</button>
    <button class="btn btn-success" style="margin-left: 0.5rem;" @onclick="OpenAddDialogAsync">Add Task</button>
</p>


@if (_loading)
{
    <p>Loading...</p>
}
else if (!string.IsNullOrEmpty(_error))
{
    <p style="color: red;">@_error</p>
}
else if (!string.IsNullOrEmpty(_actionMessage))
{
    <p style="color: green;">@_actionMessage</p>
}
else if (_view == null)
{
    <p>No data.</p>
}
else
{
    <div>
        <strong>Counters</strong>
        <div>
            Active: @_view.Counters.Active /
            Encoding: @_view.Counters.Encoding /
            Complete: @_view.Counters.Complete /
            Pending: @_view.Counters.Pending /
            Failed: @_view.Counters.Failed /
            Canceled: @_view.Counters.Canceled
        </div>
    </div>

    <h4>Items</h4>
    @if (_view.Items.Count == 0)
    {
        <p>No queue items.</p>
    }
    else
    {
        <table class="table">
            <thead>
                <tr>
                    <th>Id</th>
                    <th>State</th>
                    <th>File</th>
                    <th>Service</th>
                    <th>Profile</th>
                    <th>Priority</th>
                    <th>Progress</th>
                    <th>Start</th>
                    <th>Finish</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @for (var i = 0; i < _view.Items.Count; i++)
                {
                    var rowIndex = i;
                    var item = _view.Items[rowIndex];
                    <tr @key="item.Id"
                        draggable="true"
                        data-queue-index="@rowIndex"
                        ondragstart="return amatsukazeDnd.setDataWithIndex(event)"
                        ondragenter="return amatsukazeDnd.onEnter(event)"
                        ondragover="return amatsukazeDnd.onOver(event)"
                        @ondrop:preventDefault="true"
                        @ondrop="@(() => OnQueueDrop(rowIndex))">
                        <td>@item.Id</td>
                        <td>@(item.StateLabel ?? item.State ?? "-")</td>
                        <td>@(item.FileName ?? "-")</td>
                        <td>@(item.ServiceName ?? "-")</td>
                        <td>
                            <div>@(item.ProfileName ?? "-")</div>
                            <div>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => CopyProfileAsync(item)">Copy</button>
                            </div>
                        </td>
                        <td>
                            <input type="number" style="width: 4rem;" @bind="_priorityInputs[item.Id]" />
                            <button class="btn btn-sm btn-outline-secondary" @onclick="() => ChangePriorityAsync(item)">Set</button>
                        </td>
                        <td>@item.Progress.ToString("P1")</td>
                        <td>@(item.DisplayEncodeStart ?? item.EncodeStart?.ToString("yyyy-MM-dd HH:mm:ss") ?? "-")</td>
                        <td>@(item.DisplayEncodeFinish ?? item.EncodeFinish?.ToString("yyyy-MM-dd HH:mm:ss") ?? "-")</td>
                        <td>
                            <div>
                                <select @bind="_profileInputs[item.Id]">
                                    <option value="">(Profile)</option>
                                    @foreach (var name in _profileNames)
                                    {
                                        <option value="@name">@name</option>
                                    }
                                </select>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => ChangeProfileAsync(item)">Change</button>
                            </div>
                            <div style="margin-top: 0.25rem;">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => RetryAsync(item)">Retry</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => ReapplyProfileAsync(item)">Reapply</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => CancelAsync(item)">Cancel</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => DeleteAsync(item)">Delete</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => ForceStartAsync(item)">Force</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => OpenLogoAnalyze(item)">Logo</button>
                            </div>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

@if (_showAddDialog)
{
    <div class="modal-overlay" @onclick="CloseAddDialog">
        <div class="modal-body" @onclick:stopPropagation="true">
            <h4>Add Queue Task</h4>
            @if (!string.IsNullOrEmpty(_addError))
            {
                <p style="color: red;">@_addError</p>
            }
            <div class="form-row">
                <label>Input TS</label>
                <PathSuggestInput Value="@_addSrcPath"
                                  ValueChanged="OnAddSrcPathChanged"
                                  Placeholder="*.ts"
                                  Extensions=".ts"
                                  AllowFiles="true"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="10" />
            </div>
            <div class="form-row">
                <label>Profile</label>
                <select class="form-select" @bind="_addProfile">
                    <option value="">(Select)</option>
                    @foreach (var name in _profileNames)
                    {
                        <option value="@name">@name</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Output Dir</label>
                <PathSuggestInput Value="@_addOutDir"
                                  ValueChanged="OnAddOutDirChanged"
                                  Placeholder="/path/to/output"
                                  AllowFiles="false"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="10" />
            </div>
            <div class="form-row">
                <label>Priority</label>
                <select class="form-select" @bind="_addPriority">
                    @foreach (var p in QueueSettingExtensions.PriorityList)
                    {
                        <option value="@p">@p</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Add Queue Bat</label>
                <select class="form-select" @bind="_addAddQueueBat">
                    <option value="">(None)</option>
                    @if (_addQueueBatFiles != null)
                    {
                        @foreach (var name in _addQueueBatFiles)
                        {
                            <option value="@name">@name</option>
                        }
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Mode</label>
                <select class="form-select" @bind="_addMode">
                    @foreach (var mode in QueueSettingExtensions.QueueProcModes)
                    {
                        <option value="@mode">@QueueSettingExtensions.GetProcModeDisplay(mode)</option>
                    }
                </select>
            </div>
            <div style="margin-top: 1rem;">
                <button class="btn btn-primary" @onclick="SubmitAddQueueAsync" disabled="@_adding">Add</button>
                <button class="btn btn-secondary" style="margin-left: 0.5rem;" @onclick="CloseAddDialog" disabled="@_adding">Cancel</button>
            </div>
        </div>
    </div>
}

@code {
    private QueueView? _view;
    private string? _error;
    private bool _loading = true;
    private string? _actionMessage;
    private readonly Dictionary<int, string?> _profileInputs = new();
    private readonly Dictionary<int, int> _priorityInputs = new();
    private readonly List<JsonElement> _profiles = new();
    private readonly List<string> _profileNames = new();
    private CancellationTokenSource? _pollCts;
    private Task? _pollTask;
    private long _queueVersion;
    private string? _queueDigest;
    private bool _polling;
    private bool _showAddDialog;
    private string? _addError;
    private bool _adding;
    private string _addSrcPath = "";
    private string _addOutDir = "";
    private string _addProfile = "";
    private int _addPriority = 3;
    private string _addAddQueueBat = "";
    private ProcMode _addMode = ProcMode.Batch;
    private List<string>? _addQueueBatFiles;
    private UiStateView? _uiState;

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
        StartPolling();
    }

    private bool IsAddValid =>
        !string.IsNullOrWhiteSpace(_addSrcPath) &&
        !string.IsNullOrWhiteSpace(_addProfile) &&
        !string.IsNullOrWhiteSpace(_addOutDir);

    private async Task ReloadAsync()
    {
        _loading = true;
        _error = null;
        _actionMessage = null;
        _view = null;
        _profiles.Clear();
        _profileNames.Clear();

        var queueTask = Api.GetQueueAsync();
        var profilesTask = Api.GetProfilesAsync();

        await Task.WhenAll(queueTask, profilesTask);

        var res = await queueTask;
        var profilesRes = await profilesTask;

        if (!profilesRes.Ok)
        {
            _error = profilesRes.Error ?? "Failed to load profiles.";
        }
        else if (profilesRes.Data != null)
        {
            _profiles.AddRange(profilesRes.Data);
            foreach (var profile in _profiles)
            {
                var name = GetProfileName(profile);
                if (!string.IsNullOrEmpty(name))
                {
                    _profileNames.Add(name);
                }
            }
        }

        if (!res.Ok && string.IsNullOrEmpty(_error))
        {
            _error = res.Error ?? "Failed to load queue.";
        }
        else
        {
            _view = res.Data;
            if (_view != null)
            {
                _queueVersion = _view.Version;
                _queueDigest = _view.Digest;
                foreach (var item in _view.Items)
                {
                    if (!_profileInputs.ContainsKey(item.Id))
                    {
                        _profileInputs[item.Id] = item.ProfileName ?? "";
                    }
                    if (!_priorityInputs.ContainsKey(item.Id))
                    {
                        _priorityInputs[item.Id] = item.Priority;
                    }
                }
            }
        }

        _loading = false;
    }

    private async Task OpenAddDialogAsync()
    {
        _addError = null;
        _showAddDialog = true;
        await EnsureAddDialogDataAsync();
        StateHasChanged();
    }

    private void CloseAddDialog()
    {
        _showAddDialog = false;
        _addError = null;
    }

    private async Task EnsureAddDialogDataAsync()
    {
        if (_addQueueBatFiles == null)
        {
            var optionsRes = await Api.GetProfileOptionsAsync();
            if (optionsRes.Ok)
            {
                _addQueueBatFiles = optionsRes.Data?.PreBatFiles;
            }
        }

        if (_profileNames.Count == 0)
        {
            var profilesRes = await Api.GetProfilesAsync();
            if (profilesRes.Ok && profilesRes.Data != null)
            {
                _profiles.Clear();
                _profileNames.Clear();
                _profiles.AddRange(profilesRes.Data);
                foreach (var profile in _profiles)
                {
                    var name = GetProfileName(profile);
                    if (!string.IsNullOrEmpty(name))
                    {
                        _profileNames.Add(name);
                    }
                }
            }
        }

        if (_uiState == null)
        {
            var uiRes = await Api.GetUiStateAsync();
            if (uiRes.Ok)
            {
                _uiState = uiRes.Data;
            }
        }

        if (string.IsNullOrWhiteSpace(_addProfile))
        {
            _addProfile = _uiState?.LastUsedProfile ?? "";
        }
        if (string.IsNullOrWhiteSpace(_addProfile) && _profileNames.Count > 0)
        {
            _addProfile = _profileNames[0];
        }

        if (string.IsNullOrWhiteSpace(_addOutDir))
        {
            _addOutDir = _uiState?.LastOutputPath ?? "";
        }

        if (string.IsNullOrWhiteSpace(_addAddQueueBat))
        {
            _addAddQueueBat = _uiState?.LastAddQueueBat ?? "";
        }
    }

    private Task OnAddSrcPathChanged(string value)
    {
        _addSrcPath = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnAddOutDirChanged(string value)
    {
        _addOutDir = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task SubmitAddQueueAsync()
    {
        if (!IsAddValid)
        {
            _addError = "Required fields are missing.";
            return;
        }

        _adding = true;
        _addError = null;
        try
        {
            var dirPath = GetParentDir(_addSrcPath);
            var outDir = NormalizeOutputDir(_addOutDir);
            if (string.IsNullOrWhiteSpace(outDir))
            {
                _addError = "Output directory is invalid.";
                return;
            }
            var req = new AddQueueRequest
            {
                DirPath = dirPath,
                Targets = new List<AddQueueItem>
                {
                    new AddQueueItem { Path = _addSrcPath }
                },
                Outputs = new List<OutputInfo>
                {
                    new OutputInfo
                    {
                        DstPath = outDir,
                        Profile = _addProfile,
                        Priority = _addPriority
                    }
                },
                Mode = _addMode,
                AddQueueBat = string.IsNullOrWhiteSpace(_addAddQueueBat) ? null : _addAddQueueBat
            };

            var res = await Api.AddQueueAsync(req);
            if (!res.Ok)
            {
                _addError = TryExtractServerError(res.Error) ?? res.Error ?? "Failed to add queue item.";
                return;
            }
            _showAddDialog = false;
            await ReloadAsync();
        }
        finally
        {
            _adding = false;
        }
    }

    private static string GetParentDir(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return "";
        }
        var lastSlash = Math.Max(path.LastIndexOf('/'), path.LastIndexOf('\\'));
        if (lastSlash <= 0)
        {
            return "";
        }
        return path.Substring(0, lastSlash);
    }

    private static string NormalizeOutputDir(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return "";
        }
        var trimmed = path.Trim();
        if (trimmed.EndsWith("/") || trimmed.EndsWith("\\"))
        {
            return trimmed.TrimEnd('/', '\\');
        }
        if (Path.HasExtension(trimmed))
        {
            var dir = GetParentDir(trimmed);
            return dir;
        }
        return trimmed;
    }

    private static string? TryExtractServerError(string? error)
    {
        if (string.IsNullOrWhiteSpace(error))
        {
            return null;
        }
        try
        {
            using var doc = JsonDocument.Parse(error);
            if (doc.RootElement.TryGetProperty("error", out var errProp))
            {
                var msg = errProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
            if (doc.RootElement.TryGetProperty("detail", out var detailProp))
            {
                var msg = detailProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
        }
        catch
        {
        }
        return null;
    }

    private void StartPolling()
    {
        _pollCts?.Cancel();
        _pollCts = new CancellationTokenSource();
        var token = _pollCts.Token;
        _pollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private async Task PollOnceAsync()
    {
        if (_loading || _view == null || _polling)
        {
            return;
        }
        _polling = true;
        try
        {
            var res = await Api.GetQueueChangesAsync(_queueVersion);
            if (!res.Ok)
            {
                _error = res.Error ?? "Failed to poll queue.";
                return;
            }
            var data = res.Data;
            if (data == null)
            {
                return;
            }
            if (data.FullSyncRequired)
            {
                await ReloadAsync();
                return;
            }
            if (data.Changes.Count == 0)
            {
                var snapshot = await Api.GetQueueAsync();
                if (snapshot.Ok && snapshot.Data != null)
                {
                    if (snapshot.Data.Digest != _queueDigest)
                    {
                        ApplyQueueSnapshot(snapshot.Data);
                    }
                    else
                    {
                        _queueVersion = snapshot.Data.Version;
                        _queueDigest = snapshot.Data.Digest;
                    }
                }
                return;
            }
            ApplyQueueChanges(data);
        }
        finally
        {
            _polling = false;
        }
    }

    private void ApplyQueueChanges(QueueChangesView data)
    {
        if (_view == null)
        {
            return;
        }
        _queueVersion = data.ToVersion;
        if (!string.IsNullOrEmpty(data.QueueViewDigest))
        {
            _queueDigest = data.QueueViewDigest;
        }
        _view.Counters = data.Counters ?? _view.Counters;
        var items = _view.Items;

        foreach (var change in data.Changes)
        {
            switch (change.Type)
            {
                case QueueChangeType.Add:
                case QueueChangeType.Update:
                    if (change.Item == null)
                    {
                        continue;
                    }
                    var existingIndex = items.FindIndex(x => x.Id == change.Item.Id);
                    if (existingIndex >= 0)
                    {
                        items[existingIndex] = change.Item;
                    }
                    else
                    {
                        items.Add(change.Item);
                    }
                    _profileInputs[change.Item.Id] = change.Item.ProfileName ?? "";
                    _priorityInputs[change.Item.Id] = change.Item.Priority;
                    break;
                case QueueChangeType.Remove:
                    if (!change.Id.HasValue)
                    {
                        continue;
                    }
                    var removeIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (removeIndex >= 0)
                    {
                        items.RemoveAt(removeIndex);
                    }
                    _profileInputs.Remove(change.Id.Value);
                    _priorityInputs.Remove(change.Id.Value);
                    break;
                case QueueChangeType.Move:
                    if (!change.Id.HasValue || !change.Position.HasValue)
                    {
                        continue;
                    }
                    var moveIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (moveIndex < 0)
                    {
                        continue;
                    }
                    var item = items[moveIndex];
                    items.RemoveAt(moveIndex);
                    var targetIndex = Math.Clamp(change.Position.Value, 0, items.Count);
                    items.Insert(targetIndex, item);
                    break;
            }
        }
        StateHasChanged();
    }

    private void ApplyQueueSnapshot(QueueView snapshot)
    {
        if (_view == null)
        {
            _view = snapshot;
            _queueVersion = snapshot.Version;
            _queueDigest = snapshot.Digest;
            return;
        }
        _queueVersion = snapshot.Version;
        _queueDigest = snapshot.Digest;
        _view.Counters = snapshot.Counters;
        var items = _view.Items;

        var currentMap = items.ToDictionary(item => item.Id, item => item);
        var desired = new List<QueueItemView>(snapshot.Items.Count);
        foreach (var snap in snapshot.Items)
        {
            if (currentMap.TryGetValue(snap.Id, out var current))
            {
                CopyQueueItemView(current, snap);
                desired.Add(current);
            }
            else
            {
                desired.Add(snap);
            }
            _profileInputs[snap.Id] = snap.ProfileName ?? "";
            _priorityInputs[snap.Id] = snap.Priority;
        }
        for (var i = 0; i < desired.Count; i++)
        {
            if (i < items.Count && ReferenceEquals(items[i], desired[i]))
            {
                continue;
            }
            var existingIndex = items.FindIndex(i + 1, x => ReferenceEquals(x, desired[i]));
            if (existingIndex >= 0)
            {
                var moving = items[existingIndex];
                items.RemoveAt(existingIndex);
                items.Insert(i, moving);
            }
            else
            {
                items.Insert(i, desired[i]);
            }
        }
        if (items.Count > desired.Count)
        {
            items.RemoveRange(desired.Count, items.Count - desired.Count);
        }

        var ids = new HashSet<int>(desired.Select(item => item.Id));
        foreach (var id in _profileInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _profileInputs.Remove(id);
        }
        foreach (var id in _priorityInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _priorityInputs.Remove(id);
        }
        StateHasChanged();
    }

    private static void CopyQueueItemView(QueueItemView target, QueueItemView source)
    {
        target.FileName = source.FileName;
        target.ServiceName = source.ServiceName;
        target.ProfileName = source.ProfileName;
        target.State = source.State;
        target.StateLabel = source.StateLabel;
        target.Priority = source.Priority;
        target.IsBatch = source.IsBatch;
        target.EncodeStart = source.EncodeStart;
        target.EncodeFinish = source.EncodeFinish;
        target.DisplayEncodeStart = source.DisplayEncodeStart;
        target.DisplayEncodeFinish = source.DisplayEncodeFinish;
        target.Progress = source.Progress;
        target.ConsoleId = source.ConsoleId;
        target.OutputMask = source.OutputMask;
        target.IsTooSmall = source.IsTooSmall;
    }


    public async ValueTask DisposeAsync()
    {
        if (_pollCts != null)
        {
            _pollCts.Cancel();
        }
        if (_pollTask != null)
        {
            try
            {
                await _pollTask;
            }
            catch (OperationCanceledException)
            {
            }
        }
        _pollCts?.Dispose();
    }

    private static string? GetProfileName(JsonElement profile)
    {
        if (profile.TryGetProperty("Name", out var nameProp))
        {
            return nameProp.GetString();
        }
        if (profile.TryGetProperty("name", out var namePropLower))
        {
            return namePropLower.GetString();
        }
        return null;
    }

    private async Task CopyProfileAsync(QueueItemView item)
    {
        _actionMessage = null;
        _error = null;
        var targetName = item.ProfileName;
        if (string.IsNullOrWhiteSpace(targetName))
        {
            _error = "Profile name is empty.";
            return;
        }

        var profile = _profiles.FirstOrDefault(p => string.Equals(GetProfileName(p), targetName, StringComparison.OrdinalIgnoreCase));
        if (profile.ValueKind == JsonValueKind.Undefined)
        {
            _error = "Profile not found.";
            return;
        }

        var text = profile.GetRawText();
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            _actionMessage = "Profile copied to clipboard.";
        }
        catch
        {
            _error = "Failed to copy to clipboard.";
        }
    }

    private Task RetryAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ResetState);

    private Task ReapplyProfileAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.UpdateProfile);

    private Task CancelAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.Cancel);

    private Task DeleteAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.RemoveItem);

    private Task ForceStartAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ForceStart);

    private void OpenLogoAnalyze(QueueItemView item)
    {
        var url = $"logo-analyze?queueItemId={item.Id}";
        Nav.NavigateTo(url);
    }

    private async Task ChangePriorityAsync(QueueItemView item)
    {
        if (!_priorityInputs.TryGetValue(item.Id, out var priority))
        {
            priority = item.Priority;
        }
        await ChangeItemAsync(item, ChangeItemType.Priority, priority: priority);
    }

    private async Task ChangeProfileAsync(QueueItemView item)
    {
        if (!_profileInputs.TryGetValue(item.Id, out var profile) || string.IsNullOrWhiteSpace(profile))
        {
            _error = "Profile name is required.";
            return;
        }
        await ChangeItemAsync(item, ChangeItemType.Profile, profile: profile);
    }

    private async Task ChangeItemAsync(QueueItemView item, ChangeItemType type, int? priority = null, string? profile = null, int? position = null)
    {
        _actionMessage = null;
        _error = null;
        var req = new ChangeItemData
        {
            ItemId = item.Id,
            ChangeType = type,
            Priority = priority ?? 0,
            Profile = profile,
            Position = position ?? 0
        };
        var res = await Api.ChangeQueueAsync(req);
        if (!res.Ok)
        {
            _error = res.Error ?? "Operation failed.";
            return;
        }
        _actionMessage = "Operation completed.";
        await ReloadAsync();
    }

    private async Task OnQueueDrop(int index)
    {
        if (_view == null)
        {
            return;
        }
        var fromIndex = await JS.InvokeAsync<int>("amatsukazeDnd.getDragIndex");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearDragIndex");
        if (fromIndex < 0 || fromIndex == index)
        {
            return;
        }
        var toIndex = index;
        if (toIndex > fromIndex)
        {
            toIndex -= 1;
        }
        if (toIndex < 0)
        {
            toIndex = 0;
        }
        if (toIndex >= _view.Items.Count)
        {
            toIndex = _view.Items.Count - 1;
        }
        var item = _view.Items[fromIndex];
        await ChangeItemAsync(item, ChangeItemType.Move, position: toIndex);
    }
}
