@page "/"
@page "/queue"
@using Amatsukaze.Shared
@using System.Text.Json
@using System.Threading
@using System.IO
@using System.Linq
@inject IAmatsukazeApi Api
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject IJSRuntime JS
@implements IAsyncDisposable

<h3>キュー</h3>

<style>
    .status-toggle {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
        vertical-align: middle;
    }
    .status-toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .status-toggle .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .2s;
        border-radius: 12px;
    }
    .status-toggle .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .2s;
        border-radius: 50%;
    }
    .status-toggle input:checked + .slider {
        background-color: #4caf50;
    }
    .status-toggle input:checked + .slider:before {
        transform: translateX(20px);
    }
    .status-toggle input:disabled + .slider {
        background-color: #999;
        cursor: not-allowed;
    }
    .queue-filter-shell {
        margin: 0.5rem 0 0.75rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--bg-surface);
        padding: 0.4rem 0.75rem;
    }
    .queue-filter-shell.is-closed {
        padding-top: 0.3rem;
        padding-bottom: 0.3rem;
    }
    .queue-filter-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        min-height: 36px;
    }
    .queue-filter-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        border: 1px solid var(--border);
        background: var(--bg-surface);
        color: var(--text-strong);
        padding: 0.4rem 0.75rem;
        border-radius: 999px;
        font-weight: 600;
    }
    .queue-filter-toggle .chev {
        display: inline-block;
        transition: transform 120ms ease;
    }
    .queue-filter-toggle.is-open .chev {
        transform: rotate(90deg);
    }
    .queue-filter-panel {
        margin-top: 0.5rem;
        display: grid;
        gap: 0.5rem;
    }
    .queue-filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        align-items: center;
    }
    .queue-filter-label {
        min-width: 5.5rem;
        font-weight: 600;
        color: var(--text);
    }
    .queue-filter-input {
        min-width: 220px;
        max-width: 420px;
        flex: 1;
    }
    .queue-filter-btn {
        border: 1px solid var(--border);
        border-radius: 999px;
        background: var(--bg-surface);
        color: var(--muted);
        padding: 0.35rem 0.75rem;
        font-size: 0.9rem;
    }
    .queue-filter-btn.is-on {
        background: color-mix(in srgb, var(--accent) 18%, var(--bg-surface));
        border-color: color-mix(in srgb, var(--accent) 65%, var(--border));
        color: var(--text);
    }
    .queue-filter-btn.is-all {
        font-weight: 600;
    }
    .queue-filter-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    .queue-counters {
        margin-top: 0.5rem;
        color: var(--muted);
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        flex-wrap: wrap;
    }
    .queue-action-message {
        color: var(--muted);
    }
</style>

<div class="queue-header">
    <button class="btn btn-primary" @onclick="ReloadAsync" disabled="@_loading">更新</button>
    <button class="btn btn-success" @onclick="OpenAddDialogAsync">タスク追加</button>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>キュー</span>
        <span class="queue-header-group-body">
            <span class="status-toggle">
                <input type="checkbox"
                       checked="@IsQueueRunning"
                       disabled="@(_systemLoading || _pauseBusy || _system?.State == null)"
                       @onchange="OnToggleQueuePause" />
                <span class="slider"></span>
            </span>
            <span class="queue-header-state">@(_systemLoading ? "読込中" : (_system?.State == null ? "-" : (IsQueueRunning ? "稼働中" : "停止")))</span>
        </span>
    </label>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>エンコーダ</span>
        <span class="queue-header-group-body">
            <span class="status-toggle">
                <input type="checkbox"
                       checked="@IsEncoderOk"
                       disabled="@(_systemLoading || _suspendBusy || _system?.State == null)"
                       @onchange="OnToggleEncoderSuspend" />
                <span class="slider"></span>
            </span>
            <span class="queue-header-state">@(_systemLoading ? "読込中" : (_system?.State == null ? "-" : (IsEncoderOk ? "OK" : "一時停止")))</span>
        </span>
    </label>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>処理後</span>
        <span class="queue-header-group-body">
            <select class="form-select queue-finish-select" style="width: 180px;"
                    value="@_finishAction"
                    disabled="@(_systemLoading || _finishBusy || _system?.FinishSetting == null)"
                    @onchange="OnFinishActionChanged">
                @if (_systemLoading)
                {
                    <option value="">読込中...</option>
                }
                else if (_finishActionOptions.Count == 0)
                {
                    <option value="">-</option>
                }
                else
                {
                    @foreach (var option in _finishActionOptions)
                    {
                        <option value="@option.Value">@option.Label</option>
                    }
                }
            </select>
        </span>
    </label>
</div>

<div class="queue-filter-shell @(_isFilterOpen ? "" : "is-closed")">
    <div class="queue-filter-header">
        <button class="queue-filter-toggle @(_isFilterOpen ? "is-open" : "")" @onclick="ToggleFilterPanel">
            <span class="chev">▶</span>
            フィルタ
        </button>
        <div class="queue-filter-actions">
            <button class="btn btn-outline-secondary btn-sm" @onclick="ClearFilters">クリア</button>
        </div>
    </div>
    @if (_isFilterOpen)
    {
        <div class="queue-filter-panel">
            <div class="queue-filter-row">
                <div class="queue-filter-label">検索</div>
                <input class="form-control queue-filter-input"
                       placeholder="検索ワード"
                       value="@_filterSearchText"
                       @oninput="OnFilterSearchInput" />
            </div>
            <div class="queue-filter-row">
                <div class="queue-filter-label">検索項目</div>
                <button class="queue-filter-btn is-all @(_filterSearchAll ? "is-on" : "")" @onclick="ToggleSearchAll">すべて</button>
                <button class="queue-filter-btn @(_filterSearchFile ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.File))">ファイル名</button>
                <button class="queue-filter-btn @(_filterSearchChannel ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.Channel))">チャンネル</button>
                <button class="queue-filter-btn @(_filterSearchProfile ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.Profile))">プロファイル</button>
                <button class="queue-filter-btn @(_filterSearchGenre ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.Genre))">ジャンル</button>
                <button class="queue-filter-btn @(_filterSearchState ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.State))">状態</button>
                <button class="queue-filter-btn @(_filterSearchMode ? "is-on" : "")" @onclick="@(() => ToggleSearchTarget(FilterSearchTarget.Mode))">モード</button>
            </div>
            <div class="queue-filter-row">
                <div class="queue-filter-label">状態</div>
                <button class="queue-filter-btn is-all @(_filterStateAll ? "is-on" : "")" @onclick="ToggleStateAll">すべて</button>
                <button class="queue-filter-btn @(_filterStateWaiting ? "is-on" : "")" @onclick="@(() => ToggleStateFilter(FilterStateTarget.Waiting))">待ち</button>
                <button class="queue-filter-btn @(_filterStatePending ? "is-on" : "")" @onclick="@(() => ToggleStateFilter(FilterStateTarget.Pending))">ペンディング</button>
                <button class="queue-filter-btn @(_filterStateRunning ? "is-on" : "")" @onclick="@(() => ToggleStateFilter(FilterStateTarget.Running))">実行中</button>
                <button class="queue-filter-btn @(_filterStateCanceled ? "is-on" : "")" @onclick="@(() => ToggleStateFilter(FilterStateTarget.Canceled))">キャンセル</button>
                <button class="queue-filter-btn @(_filterStateComplete ? "is-on" : "")" @onclick="@(() => ToggleStateFilter(FilterStateTarget.Complete))">完了</button>
            </div>
        </div>
    }
</div>

@if (_loading)
{
    <p>Loading...</p>
}
else if (!string.IsNullOrEmpty(_error))
{
    <p style="color: red;">@_error</p>
}
else if (_view == null)
{
    <p>No data.</p>
}
else
{
    @if (_filteredItems.Count == 0)
    {
        <p>No queue items.</p>
    }
    else
    {
        <div class="queue-list"
             @ref="_queueListElement"
             data-drop-end="true"
             ondragover="return amatsukazeDnd.updateDropIdFromEvent(event)"
             @onclick="CloseContextMenu"
             @ondragenter="OnQueueBodyDragEnter">
        <table class="table queue-table"
               data-drop-end="true"
               ondragover="return amatsukazeDnd.updateDropIdFromEvent(event)"
               @ondragenter="OnQueueBodyDragEnter">
            <thead>
                <tr>
                    <th>タスク<br>放送日 / チャンネル</th>
                    <th>入力ファイル</th>
                    <th>プロファイル<br>状態 / 優先度</th>
                </tr>
            </thead>
            <tbody @ondragover:preventDefault="true"
                   @ondrop:preventDefault="true"
                   @ondrop="OnQueueDropFromBody"
                   @ondragenter="OnQueueBodyDragEnter"
                   @ondragend="OnQueueDragEnd"
                   >
                @for (var i = 0; i < _filteredItems.Count; i++)
                {
                    var rowIndex = i;
                    var item = _filteredItems[rowIndex];
                    <tr @key="item.Id"
                        class="@GetRowClass(item, rowIndex)"
                        draggable="true"
                        data-queue-index="@rowIndex"
                        data-queue-id="@item.Id"
                        ondragstart="return amatsukazeDnd.setDataWithQueueId(event)"
                        ondragover="return amatsukazeDnd.updateDropIdFromEvent(event)"
                        @ondragenter="(() => OnQueueDragEnter(rowIndex))"
                        @ondragend="OnQueueDragEnd"
                        @onclick="(e => OnRowClick(item, e))"
                        @onclick:stopPropagation="true"
                        @oncontextmenu="(e => OnRowContextMenu(item, e))"
                        @oncontextmenu:preventDefault="true"
                        @oncontextmenu:stopPropagation="true"
                        @ondrop:preventDefault="true"
                        @ondrop="OnQueueDropFromRow">
                        <td>
                            <div class="queue-cell-stack">
                                <div class="queue-cell-line queue-task">@GetTaskLabel(item)</div>
                                <div class="queue-cell-line queue-channel">@GetBroadcastDateShort(item) @@ @ToHalfWidth(GetBroadcastChannel(item))</div>
                            </div>
                        </td>
                        <td class="queue-input-file" title="@BuildQueueTooltip(item)">@GetInputFile(item)</td>
                        <td class="queue-actions-cell">
                            <div class="queue-cell-stack">
                                <div class="queue-cell-line">
                                    <select class="queue-profile-select"
                                            @bind="_profileInputs[item.Id]"
                                            @bind:after="(() => ChangeProfileAsync(item))">
                                        @foreach (var name in _profileNames)
                                        {
                                            <option value="@name">@name</option>
                                        }
                                    </select>
                                </div>
                                <div class="queue-cell-line queue-state-priority">
                                    <span class="queue-state">@GetStateText(item)</span>
                                    <input type="number" class="queue-priority-input"
                                           min="@MinPriority"
                                           max="@MaxPriority"
                                           step="1"
                                           @bind="_priorityInputs[item.Id]"
                                           @bind:after="(() => ChangePriorityAsync(item))" />
                                </div>
                            </div>
                        </td>
                    </tr>
                }
                <tr class="@GetDropRowClass()"
                    data-drop-end="true"
                    ondragover="return amatsukazeDnd.onOverWithId(event)"
                    @ondragenter="(() => OnQueueDragEnter(_filteredItems.Count))"
                    @ondragend="OnQueueDragEnd">
                    <td colspan="3"></td>
                </tr>
            </tbody>
        </table>
        @if (_contextMenuVisible)
        {
            <div class="queue-context-menu"
                 style="left: @_contextMenuXpx; top: @_contextMenuYpx;"
                 @onclick:stopPropagation="true">
                <button class="queue-menu-item" @onclick="OpenConsoleSelected">コンソール</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.ResetState, "リトライ"))' disabled="@(!_hasSelection)">リトライ</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.UpdateProfile, "プロファイル再適用"))' disabled="@(!_hasSelection)">プロファイル再適用</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.Cancel, "キャンセル"))' disabled="@(!_hasSelection)">キャンセル</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.RemoveItem, "削除"))' disabled="@(!_hasSelection)">削除</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.ForceStart, "強制実行"))' disabled="@(!_hasSelection)">強制実行</button>
                <button class="queue-menu-item" @onclick="(() => OpenLogoAnalyzeSelectedAsync())" disabled="@(!_hasSelection)">ロゴ解析</button>
                <button class="queue-menu-item" @onclick="ClearSucceededAsync">成功済みをクリア</button>
            </div>
        }
        </div>
    }
    <div class="queue-counters">
        Active: @_view.Counters.Active /
        Encoding: @_view.Counters.Encoding /
        Complete: @_view.Counters.Complete /
        Pending: @_view.Counters.Pending /
        Failed: @_view.Counters.Failed /
        Canceled: @_view.Counters.Canceled
        @if (!string.IsNullOrEmpty(_actionMessage))
        {
            <span class="queue-action-message">/ @_actionMessage</span>
        }
    </div>
}

@if (_showAddDialog)
{
    <div class="modal-overlay" @onclick="CloseAddDialog">
        <div class="modal-body" @onclick:stopPropagation="true">
            <h4>キュー追加</h4>
            @if (!string.IsNullOrEmpty(_addError))
            {
                <p style="color: red;">@_addError</p>
            }
            <div class="form-row">
                <label>Input TS</label>
                <PathSuggestInput Value="@_addSrcPath"
                                  ValueChanged="OnAddSrcPathChanged"
                                  Placeholder="*.ts"
                                  Extensions=".ts"
                                  AllowFiles="true"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="20" />
            </div>
            <div class="form-row">
                <label>Profile</label>
                <select class="form-select" @bind="_addProfile">
                    <option value="">(Select)</option>
                    @foreach (var name in _profileNames)
                    {
                        <option value="@name">@name</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Output Dir</label>
                <PathSuggestInput Value="@_addOutDir"
                                  ValueChanged="OnAddOutDirChanged"
                                  Placeholder="/path/to/output"
                                  AllowFiles="false"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="20" />
            </div>
            <div class="form-row">
                <label>Priority</label>
                <select class="form-select" @bind="_addPriority">
                    @foreach (var p in QueueSettingExtensions.PriorityList)
                    {
                        <option value="@p">@p</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>追加時バッチ</label>
                <select class="form-select" @bind="_addAddQueueBat">
                    <option value="">(None)</option>
                    @if (_addQueueBatFiles != null)
                    {
                        @foreach (var name in _addQueueBatFiles)
                        {
                            <option value="@name">@name</option>
                        }
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Mode</label>
                <select class="form-select" @bind="_addMode">
                    @foreach (var mode in QueueSettingExtensions.QueueProcModes)
                    {
                        <option value="@mode">@QueueSettingExtensions.GetProcModeDisplay(mode)</option>
                    }
                </select>
            </div>
            <div style="margin-top: 1rem;">
                <button class="btn btn-primary" @onclick="SubmitAddQueueAsync" disabled="@_adding">Add</button>
                <button class="btn btn-secondary" style="margin-left: 0.5rem;" @onclick="CloseAddDialog" disabled="@_adding">Cancel</button>
            </div>
        </div>
    </div>
}

@code {
    private QueueView? _view;
    private SystemSnapshot? _system;
    private string? _error;
    private string? _systemError;
    private bool _loading = true;
    private bool _systemLoading = true;
    private string? _actionMessage;
    private readonly Dictionary<int, string?> _profileInputs = new();
    private readonly Dictionary<int, int> _priorityInputs = new();
    private readonly List<JsonElement> _profiles = new();
    private readonly List<string> _profileNames = new();
    private List<QueueItemView> _filteredItems = new();
    private Dictionary<int, int> _indexById = new();
    private Dictionary<int, int> _filteredIndexById = new();
    private readonly HashSet<int> _selectedIds = new();
    private int? _selectionAnchorId;
    private bool _contextMenuVisible;
    private double _contextMenuX;
    private double _contextMenuY;
    private const double ContextMenuHeight = 260;
    private const double ContextMenuMargin = 8;
    private int _dropIndex = -1;
    private bool _isDragging;
    private ElementReference _queueListElement;
    private CancellationTokenSource? _pollCts;
    private Task? _pollTask;
    private long _queueVersion;
    private string? _queueDigest;
    private bool _polling;
    private bool _systemPolling;
    private CancellationTokenSource? _systemPollCts;
    private Task? _systemPollTask;
    private bool _pauseBusy;
    private bool _suspendBusy;
    private bool _finishBusy;
    private readonly List<FinishActionOptionView> _finishActionOptions = new();
    private string _finishAction = "";
    private bool _showAddDialog;
    private string? _addError;
    private bool _adding;
    private string _addSrcPath = "";
    private string _addOutDir = "";
    private string _addProfile = "";
    private int _addPriority = 3;
    private string _addAddQueueBat = "";
    private ProcMode _addMode = ProcMode.Batch;
    private List<string>? _addQueueBatFiles;
    private UiStateView? _uiState;
    private string _filterSearchText = "";
    private bool _filterSearchAll = true;
    private bool _filterSearchFile = true;
    private bool _filterSearchChannel = true;
    private bool _filterSearchProfile = true;
    private bool _filterSearchGenre = true;
    private bool _filterSearchState = true;
    private bool _filterSearchMode = true;
    private bool _filterStateAll = true;
    private bool _filterStateWaiting = true;
    private bool _filterStatePending = true;
    private bool _filterStateRunning = true;
    private bool _filterStateCanceled = true;
    private bool _filterStateComplete = true;
    private bool _isFilterOpen;
    private const int MinPriority = 1;
    private const int MaxPriority = 5;
    private bool _hasSelection => _selectedIds.Count > 0;
    private string _contextMenuXpx => $"{_contextMenuX:0}px";
    private string _contextMenuYpx => $"{_contextMenuY:0}px";

    private bool IsQueueRunning => _system?.State != null && !_system.State.Pause;
    private bool IsEncoderOk => _system?.State != null && !_system.State.Suspend;

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
        _ = PollSystemOnceAsync();
        StartPolling();
        StartSystemPolling();
    }

    private bool IsAddValid =>
        !string.IsNullOrWhiteSpace(_addSrcPath) &&
        !string.IsNullOrWhiteSpace(_addProfile) &&
        !string.IsNullOrWhiteSpace(_addOutDir);

    private Task ReloadAsync()
        => ReloadAsyncCore(preserveScroll: false);

    private async Task ReloadAsyncCore(bool preserveScroll)
    {
        var restoreScrollTop = preserveScroll ? await CaptureQueueScrollTopAsync() : (double?)null;
        _loading = true;
        _error = null;
        _actionMessage = null;
        _view = null;
        _profiles.Clear();
        _profileNames.Clear();

        var queueTask = Api.GetQueueAsync();
        var profilesTask = Api.GetProfilesAsync();

        await Task.WhenAll(queueTask, profilesTask);

        var res = await queueTask;
        var profilesRes = await profilesTask;

        if (!profilesRes.Ok)
        {
            _error = profilesRes.Error ?? "Failed to load profiles.";
        }
        else if (profilesRes.Data != null)
        {
            _profiles.AddRange(profilesRes.Data);
            foreach (var profile in _profiles)
            {
                var name = GetProfileName(profile);
                if (!string.IsNullOrEmpty(name))
                {
                    _profileNames.Add(name);
                }
            }
        }

        if (!res.Ok && string.IsNullOrEmpty(_error))
        {
            _error = res.Error ?? "Failed to load queue.";
        }
        else
        {
            _view = res.Data;
            if (_view != null)
            {
                _queueVersion = _view.Version;
                _queueDigest = _view.Digest;
                foreach (var item in _view.Items)
                {
                    if (!_profileInputs.ContainsKey(item.Id))
                    {
                        _profileInputs[item.Id] = item.ProfileName ?? "";
                    }
                    if (!_priorityInputs.ContainsKey(item.Id))
                    {
                        _priorityInputs[item.Id] = ClampPriority(item.Priority);
                    }
                }
                if (_selectedIds.Count > 0)
                {
                    var ids = _view.Items.Select(x => x.Id).ToHashSet();
                    _selectedIds.RemoveWhere(id => !ids.Contains(id));
                    if (_selectionAnchorId.HasValue && !ids.Contains(_selectionAnchorId.Value))
                    {
                        _selectionAnchorId = _view.Items.FirstOrDefault(x => _selectedIds.Contains(x.Id))?.Id;
                    }
                }
            }
        }

        RebuildFilteredItems();
        _loading = false;

        if (restoreScrollTop.HasValue)
        {
            await InvokeAsync(StateHasChanged);
            await Task.Yield();
            await RestoreQueueScrollTopAsync(restoreScrollTop.Value);
        }
    }

    private async Task ReloadSystemAsync()
    {
        var res = await Api.GetSystemAsync();
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to load system status.";
            return;
        }
        _systemError = null;
        _system = res.Data;
        _finishActionOptions.Clear();
        if (_system?.FinishActionOptions != null)
        {
            _finishActionOptions.AddRange(_system.FinishActionOptions);
        }
        _finishAction = _system?.FinishSetting?.Action ?? "";
    }

    private void RebuildFilteredItems()
    {
        if (_view == null)
        {
            _filteredItems = new List<QueueItemView>();
            _indexById = new Dictionary<int, int>();
            _filteredIndexById = new Dictionary<int, int>();
            _selectedIds.Clear();
            _selectionAnchorId = null;
            _contextMenuVisible = false;
            return;
        }

        var items = _view.Items;
        var indexById = new Dictionary<int, int>(items.Count);
        for (var i = 0; i < items.Count; i++)
        {
            indexById[items[i].Id] = i;
        }
        _indexById = indexById;

        var filtered = new List<QueueItemView>(items.Count);
        foreach (var item in items)
        {
            if (!MatchesStateFilter(item))
            {
                continue;
            }
            if (!MatchesSearchFilter(item))
            {
                continue;
            }
            filtered.Add(item);
        }
        _filteredItems = filtered;
        _filteredIndexById = new Dictionary<int, int>(filtered.Count);
        for (var i = 0; i < filtered.Count; i++)
        {
            _filteredIndexById[filtered[i].Id] = i;
        }

        var visibleIds = new HashSet<int>(filtered.Select(x => x.Id));
        if (_selectedIds.RemoveWhere(id => !visibleIds.Contains(id)) > 0 && _selectedIds.Count == 0)
        {
            _contextMenuVisible = false;
        }
        if (_selectionAnchorId.HasValue && !visibleIds.Contains(_selectionAnchorId.Value))
        {
            _selectionAnchorId = _filteredItems.FirstOrDefault(x => _selectedIds.Contains(x.Id))?.Id;
        }
    }

    private bool MatchesSearchFilter(QueueItemView item)
    {
        if (string.IsNullOrWhiteSpace(_filterSearchText))
        {
            return true;
        }
        var search = NormalizeSearchText(_filterSearchText);
        if (string.IsNullOrEmpty(search))
        {
            return true;
        }

        var anyTarget = _filterSearchFile || _filterSearchChannel || _filterSearchProfile || _filterSearchGenre || _filterSearchState || _filterSearchMode;
        if (!anyTarget)
        {
            return false;
        }
        var targetAll = _filterSearchAll;

        if (targetAll || _filterSearchFile)
        {
            if (ContainsNormalized(item.FileName, search))
            {
                return true;
            }
        }
        if (targetAll || _filterSearchChannel)
        {
            if (ContainsNormalized(item.ServiceName, search))
            {
                return true;
            }
        }
        if (targetAll || _filterSearchProfile)
        {
            if (ContainsNormalized(item.ProfileName, search))
            {
                return true;
            }
        }
        if (targetAll || _filterSearchGenre)
        {
            if (ContainsNormalized(item.GenreNames, search))
            {
                return true;
            }
        }
        if (targetAll || _filterSearchState)
        {
            if (ContainsNormalized(item.StateLabel, search) || ContainsNormalized(item.State, search))
            {
                return true;
            }
        }
        if (targetAll || _filterSearchMode)
        {
            var modeText = QueueSettingExtensions.GetProcModeDisplay(item.Mode);
            if (ContainsNormalized(modeText, search) || ContainsNormalized(item.Mode.ToString(), search))
            {
                return true;
            }
        }

        return false;
    }

    private bool MatchesStateFilter(QueueItemView item)
    {
        if (_filterStateAll)
        {
            return true;
        }

        if (!_filterStateWaiting && !_filterStatePending && !_filterStateRunning && !_filterStateCanceled && !_filterStateComplete)
        {
            return false;
        }

        var category = GetStateCategory(item);
        return category switch
        {
            QueueStateCategory.Waiting => _filterStateWaiting,
            QueueStateCategory.Pending => _filterStatePending,
            QueueStateCategory.Running => _filterStateRunning,
            QueueStateCategory.Canceled => _filterStateCanceled,
            QueueStateCategory.Complete => _filterStateComplete,
            QueueStateCategory.Failed => false,
            _ => false
        };
    }

    private enum QueueStateCategory
    {
        Waiting,
        Pending,
        Running,
        Canceled,
        Complete,
        Failed,
        Unknown
    }

    private static QueueStateCategory GetStateCategory(QueueItemView item)
    {
        var state = item.State ?? string.Empty;
        if (state.Equals("Queue", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Waiting;
        }
        if (state.Equals("LogoPending", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Pending;
        }
        if (state.Equals("Encoding", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Running;
        }
        if (state.Equals("Canceled", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Canceled;
        }
        if (state.Equals("Complete", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Complete;
        }
        if (state.Equals("Failed", StringComparison.OrdinalIgnoreCase) || state.Equals("PreFailed", StringComparison.OrdinalIgnoreCase))
        {
            return QueueStateCategory.Failed;
        }

        var label = item.StateLabel ?? string.Empty;
        if (label.Contains("待ち", StringComparison.Ordinal))
        {
            return QueueStateCategory.Waiting;
        }
        if (label.Contains("ペンディング", StringComparison.Ordinal))
        {
            return QueueStateCategory.Pending;
        }
        if (label.Contains("実行中", StringComparison.Ordinal) || label.Contains("エンコード", StringComparison.Ordinal))
        {
            return QueueStateCategory.Running;
        }
        if (label.Contains("キャンセル", StringComparison.Ordinal))
        {
            return QueueStateCategory.Canceled;
        }
        if (label.Contains("完了", StringComparison.Ordinal))
        {
            return QueueStateCategory.Complete;
        }
        if (label.Contains("失敗", StringComparison.Ordinal))
        {
            return QueueStateCategory.Failed;
        }

        return QueueStateCategory.Unknown;
    }

    private static bool ContainsNormalized(string? value, string search)
    {
        if (string.IsNullOrEmpty(value))
        {
            return false;
        }
        return NormalizeSearchText(value).Contains(search, StringComparison.Ordinal);
    }

    private static bool ContainsNormalized(IEnumerable<string>? values, string search)
    {
        if (values == null)
        {
            return false;
        }
        foreach (var value in values)
        {
            if (ContainsNormalized(value, search))
            {
                return true;
            }
        }
        return false;
    }

    private static string NormalizeSearchText(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return string.Empty;
        }
        return ToHalfWidth(value).ToLowerInvariant();
    }

    private enum FilterSearchTarget
    {
        File,
        Channel,
        Profile,
        Genre,
        State,
        Mode
    }

    private enum FilterStateTarget
    {
        Waiting,
        Pending,
        Running,
        Canceled,
        Complete
    }

    private void ToggleFilterPanel()
    {
        _isFilterOpen = !_isFilterOpen;
    }

    private void ApplyFilter()
    {
        RebuildFilteredItems();
    }

    private void ClearFilters()
    {
        _filterSearchText = "";
        _filterSearchAll = true;
        _filterSearchFile = true;
        _filterSearchChannel = true;
        _filterSearchProfile = true;
        _filterSearchGenre = true;
        _filterSearchState = true;
        _filterSearchMode = true;

        _filterStateAll = true;
        _filterStateWaiting = true;
        _filterStatePending = true;
        _filterStateRunning = true;
        _filterStateCanceled = true;
        _filterStateComplete = true;

        RebuildFilteredItems();
    }

    private void OnFilterSearchInput(ChangeEventArgs e)
    {
        _filterSearchText = e.Value?.ToString() ?? "";
        RebuildFilteredItems();
    }

    private void ToggleSearchAll()
    {
        _filterSearchAll = !_filterSearchAll;
        if (_filterSearchAll)
        {
            _filterSearchFile = true;
            _filterSearchChannel = true;
            _filterSearchProfile = true;
            _filterSearchGenre = true;
            _filterSearchState = true;
            _filterSearchMode = true;
        }
        else
        {
            _filterSearchFile = false;
            _filterSearchChannel = false;
            _filterSearchProfile = false;
            _filterSearchGenre = false;
            _filterSearchState = false;
            _filterSearchMode = false;
        }
        RebuildFilteredItems();
    }

    private void ToggleSearchTarget(FilterSearchTarget target)
    {
        switch (target)
        {
            case FilterSearchTarget.File:
                _filterSearchFile = !_filterSearchFile;
                break;
            case FilterSearchTarget.Channel:
                _filterSearchChannel = !_filterSearchChannel;
                break;
            case FilterSearchTarget.Profile:
                _filterSearchProfile = !_filterSearchProfile;
                break;
            case FilterSearchTarget.Genre:
                _filterSearchGenre = !_filterSearchGenre;
                break;
            case FilterSearchTarget.State:
                _filterSearchState = !_filterSearchState;
                break;
            case FilterSearchTarget.Mode:
                _filterSearchMode = !_filterSearchMode;
                break;
        }
        _filterSearchAll = _filterSearchFile && _filterSearchChannel && _filterSearchProfile && _filterSearchGenre && _filterSearchState && _filterSearchMode;
        RebuildFilteredItems();
    }

    private void ToggleStateAll()
    {
        _filterStateAll = !_filterStateAll;
        if (_filterStateAll)
        {
            _filterStateWaiting = true;
            _filterStatePending = true;
            _filterStateRunning = true;
            _filterStateCanceled = true;
            _filterStateComplete = true;
        }
        else
        {
            _filterStateWaiting = false;
            _filterStatePending = false;
            _filterStateRunning = false;
            _filterStateCanceled = false;
            _filterStateComplete = false;
        }
        RebuildFilteredItems();
    }

    private void ToggleStateFilter(FilterStateTarget target)
    {
        switch (target)
        {
            case FilterStateTarget.Waiting:
                _filterStateWaiting = !_filterStateWaiting;
                break;
            case FilterStateTarget.Pending:
                _filterStatePending = !_filterStatePending;
                break;
            case FilterStateTarget.Running:
                _filterStateRunning = !_filterStateRunning;
                break;
            case FilterStateTarget.Canceled:
                _filterStateCanceled = !_filterStateCanceled;
                break;
            case FilterStateTarget.Complete:
                _filterStateComplete = !_filterStateComplete;
                break;
        }
        _filterStateAll = _filterStateWaiting && _filterStatePending && _filterStateRunning && _filterStateCanceled && _filterStateComplete;
        RebuildFilteredItems();
    }

    private void StartSystemPolling()
    {
        _systemPollCts?.Cancel();
        _systemPollCts = new CancellationTokenSource();
        var token = _systemPollCts.Token;
        _systemPollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollSystemOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private async Task PollSystemOnceAsync()
    {
        if (_loading || _systemPolling)
        {
            return;
        }
        _systemPolling = true;
        try
        {
            await ReloadSystemAsync();
        }
        finally
        {
            _systemPolling = false;
            _systemLoading = false;
            StateHasChanged();
        }
    }

    private async Task OpenAddDialogAsync()
    {
        _addError = null;
        _showAddDialog = true;
        await EnsureAddDialogDataAsync();
        StateHasChanged();
    }

    private void CloseAddDialog()
    {
        _showAddDialog = false;
        _addError = null;
    }

    private async Task EnsureAddDialogDataAsync()
    {
        if (_addQueueBatFiles == null)
        {
            var optionsRes = await Api.GetProfileOptionsAsync();
            if (optionsRes.Ok)
            {
                _addQueueBatFiles = optionsRes.Data?.PreBatFiles;
            }
        }

        if (_profileNames.Count == 0)
        {
            var profilesRes = await Api.GetProfilesAsync();
            if (profilesRes.Ok && profilesRes.Data != null)
            {
                _profiles.Clear();
                _profileNames.Clear();
                _profiles.AddRange(profilesRes.Data);
                foreach (var profile in _profiles)
                {
                    var name = GetProfileName(profile);
                    if (!string.IsNullOrEmpty(name))
                    {
                        _profileNames.Add(name);
                    }
                }
            }
        }

        if (_uiState == null)
        {
            var uiRes = await Api.GetUiStateAsync();
            if (uiRes.Ok)
            {
                _uiState = uiRes.Data;
            }
        }

        if (string.IsNullOrWhiteSpace(_addProfile))
        {
            _addProfile = _uiState?.LastUsedProfile ?? "";
        }
        if (string.IsNullOrWhiteSpace(_addProfile) && _profileNames.Count > 0)
        {
            _addProfile = _profileNames[0];
        }

        if (string.IsNullOrWhiteSpace(_addOutDir))
        {
            _addOutDir = _uiState?.LastOutputPath ?? "";
        }

        if (string.IsNullOrWhiteSpace(_addAddQueueBat))
        {
            _addAddQueueBat = _uiState?.LastAddQueueBat ?? "";
        }
    }

    private Task OnAddSrcPathChanged(string value)
    {
        _addSrcPath = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnAddOutDirChanged(string value)
    {
        _addOutDir = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task SubmitAddQueueAsync()
    {
        if (!IsAddValid)
        {
            _addError = "Required fields are missing.";
            return;
        }

        _adding = true;
        _addError = null;
        try
        {
            var dirPath = GetParentDir(_addSrcPath);
            var outDir = NormalizeOutputDir(_addOutDir);
            if (string.IsNullOrWhiteSpace(outDir))
            {
                _addError = "Output directory is invalid.";
                return;
            }
            var req = new AddQueueRequest
            {
                DirPath = dirPath,
                Targets = new List<AddQueueItem>
                {
                    new AddQueueItem { Path = _addSrcPath }
                },
                Outputs = new List<OutputInfo>
                {
                    new OutputInfo
                    {
                        DstPath = outDir,
                        Profile = _addProfile,
                        Priority = _addPriority
                    }
                },
                Mode = _addMode,
                AddQueueBat = string.IsNullOrWhiteSpace(_addAddQueueBat) ? null : _addAddQueueBat
            };

            var res = await Api.AddQueueAsync(req);
            if (!res.Ok)
            {
                _addError = TryExtractServerError(res.Error) ?? res.Error ?? "Failed to add queue item.";
                return;
            }
            _showAddDialog = false;
            await ReloadAsync();
        }
        finally
        {
            _adding = false;
        }
    }

    private static string GetParentDir(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return "";
        }
        var lastSlash = Math.Max(path.LastIndexOf('/'), path.LastIndexOf('\\'));
        if (lastSlash <= 0)
        {
            return "";
        }
        return path.Substring(0, lastSlash);
    }

    private static string NormalizeOutputDir(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return "";
        }
        var trimmed = path.Trim();
        if (trimmed.EndsWith("/") || trimmed.EndsWith("\\"))
        {
            return trimmed.TrimEnd('/', '\\');
        }
        if (Path.HasExtension(trimmed))
        {
            var dir = GetParentDir(trimmed);
            return dir;
        }
        return trimmed;
    }

    private static string? TryExtractServerError(string? error)
    {
        if (string.IsNullOrWhiteSpace(error))
        {
            return null;
        }
        try
        {
            using var doc = JsonDocument.Parse(error);
            if (doc.RootElement.TryGetProperty("error", out var errProp))
            {
                var msg = errProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
            if (doc.RootElement.TryGetProperty("detail", out var detailProp))
            {
                var msg = detailProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
        }
        catch
        {
        }
        return null;
    }

    private void StartPolling()
    {
        _pollCts?.Cancel();
        _pollCts = new CancellationTokenSource();
        var token = _pollCts.Token;
        _pollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private Task PollOnceAsync()
        => PollOnceAsyncCore(preserveScrollOnFullSync: true);

    private async Task PollOnceAsyncCore(bool preserveScrollOnFullSync)
    {
        if (_loading || _view == null || _polling)
        {
            return;
        }
        _polling = true;
        try
        {
            var res = await Api.GetQueueChangesAsync(_queueVersion);
            if (!res.Ok)
            {
                _error = res.Error ?? "Failed to poll queue.";
                return;
            }
            var data = res.Data;
            if (data == null)
            {
                return;
            }
            if (data.FullSyncRequired)
            {
                await ReloadAsyncCore(preserveScrollOnFullSync);
                return;
            }
            if (data.Changes.Count == 0)
            {
                var snapshot = await Api.GetQueueAsync();
                if (snapshot.Ok && snapshot.Data != null)
                {
                    if (snapshot.Data.Digest != _queueDigest)
                    {
                        ApplyQueueSnapshot(snapshot.Data);
                    }
                    else
                    {
                        _queueVersion = snapshot.Data.Version;
                        _queueDigest = snapshot.Data.Digest;
                    }
                }
                return;
            }
            await ApplyQueueChangesAsync(data);
        }
        finally
        {
            _polling = false;
        }
    }

    private async Task ApplyQueueChangesAsync(QueueChangesView data)
    {
        if (_view == null)
        {
            return;
        }
        _queueVersion = data.ToVersion;
        if (!string.IsNullOrEmpty(data.QueueViewDigest))
        {
            _queueDigest = data.QueueViewDigest;
        }
        _view.Counters = data.Counters ?? _view.Counters;
        var moveChanges = data.Changes.Count(change => change.Type == QueueChangeType.Move);
        if (moveChanges >= 32 && moveChanges * 2 >= data.Changes.Count)
        {
            var snapshotRes = await Api.GetQueueAsync();
            if (snapshotRes.Ok && snapshotRes.Data != null)
            {
                ApplyQueueSnapshot(snapshotRes.Data);
                return;
            }
        }
        var items = _view.Items;

        foreach (var change in data.Changes)
        {
            switch (change.Type)
            {
                case QueueChangeType.Add:
                case QueueChangeType.Update:
                    if (change.Item == null)
                    {
                        continue;
                    }
                    var existingIndex = items.FindIndex(x => x.Id == change.Item.Id);
                    if (existingIndex >= 0)
                    {
                        items[existingIndex] = change.Item;
                    }
                    else
                    {
                        items.Add(change.Item);
                    }
                    _profileInputs[change.Item.Id] = change.Item.ProfileName ?? "";
                    _priorityInputs[change.Item.Id] = change.Item.Priority;
                    break;
                case QueueChangeType.Remove:
                    if (!change.Id.HasValue)
                    {
                        continue;
                    }
                    var removeIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (removeIndex >= 0)
                    {
                        items.RemoveAt(removeIndex);
                    }
                    _profileInputs.Remove(change.Id.Value);
                    _priorityInputs.Remove(change.Id.Value);
                    break;
                case QueueChangeType.Move:
                    if (!change.Id.HasValue || !change.Position.HasValue)
                    {
                        continue;
                    }
                    var moveIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (moveIndex < 0)
                    {
                        continue;
                    }
                    var item = items[moveIndex];
                    items.RemoveAt(moveIndex);
                    var targetIndex = Math.Clamp(change.Position.Value, 0, items.Count);
                    items.Insert(targetIndex, item);
                    break;
            }
        }
        RebuildFilteredItems();
        StateHasChanged();
    }

    private void ApplyQueueSnapshot(QueueView snapshot)
    {
        try
        {
            ApplyQueueSnapshotCore(snapshot);
        }
        catch (Exception ex)
        {
            System.Console.WriteLine($"[Queue] ApplyQueueSnapshot failed: {ex}");
            ApplyQueueSnapshotFallback(snapshot);
        }
    }

    private void ApplyQueueSnapshotCore(QueueView snapshot)
    {
        _queueVersion = snapshot.Version;
        _queueDigest = snapshot.Digest;
        if (_view == null)
        {
            _view = snapshot;
            SyncInputs(snapshot.Items);
            RebuildFilteredItems();
            StateHasChanged();
            return;
        }
        _view.Counters = snapshot.Counters;
        _view.Filters = snapshot.Filters;

        var currentMap = _view.Items.ToDictionary(item => item.Id, item => item);
        var desired = new List<QueueItemView>(snapshot.Items.Count);
        foreach (var snap in snapshot.Items)
        {
            if (currentMap.TryGetValue(snap.Id, out var current))
            {
                CopyQueueItemView(current, snap);
                desired.Add(current);
            }
            else
            {
                desired.Add(snap);
            }
        }
        _view.Items = desired;
        SyncInputs(desired);
        RebuildFilteredItems();
        StateHasChanged();
    }

    private void ApplyQueueSnapshotFallback(QueueView snapshot)
    {
        _view = snapshot;
        _queueVersion = snapshot.Version;
        _queueDigest = snapshot.Digest;
        SyncInputs(snapshot.Items);
        RebuildFilteredItems();
        StateHasChanged();
    }

    private void SyncInputs(IEnumerable<QueueItemView> items)
    {
        var ids = new HashSet<int>();
        foreach (var item in items)
        {
            ids.Add(item.Id);
            _profileInputs[item.Id] = item.ProfileName ?? "";
            _priorityInputs[item.Id] = item.Priority;
        }
        foreach (var id in _profileInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _profileInputs.Remove(id);
        }
        foreach (var id in _priorityInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _priorityInputs.Remove(id);
        }
    }

    private async Task<double?> CaptureQueueScrollTopAsync()
    {
        try
        {
            return await JS.InvokeAsync<double>("amatsukazeUi.getScrollTop", _queueListElement);
        }
        catch
        {
            return null;
        }
    }

    private async Task RestoreQueueScrollTopAsync(double top)
    {
        try
        {
            await JS.InvokeVoidAsync("amatsukazeUi.setScrollTop", _queueListElement, top);
        }
        catch
        {
        }
    }

    private static void CopyQueueItemView(QueueItemView target, QueueItemView source)
    {
        target.FileName = source.FileName;
        target.ServiceName = source.ServiceName;
        target.ProfileName = source.ProfileName;
        target.State = source.State;
        target.StateLabel = source.StateLabel;
        target.Priority = source.Priority;
        target.IsBatch = source.IsBatch;
        target.EncodeStart = source.EncodeStart;
        target.EncodeFinish = source.EncodeFinish;
        target.DisplayEncodeStart = source.DisplayEncodeStart;
        target.DisplayEncodeFinish = source.DisplayEncodeFinish;
        target.Progress = source.Progress;
        target.ConsoleId = source.ConsoleId;
        target.OutputMask = source.OutputMask;
        target.IsTooSmall = source.IsTooSmall;
    }


    public async ValueTask DisposeAsync()
    {
        if (_pollCts != null)
        {
            _pollCts.Cancel();
        }
        if (_systemPollCts != null)
        {
            _systemPollCts.Cancel();
        }
        if (_pollTask != null)
        {
            try
            {
                await _pollTask;
            }
            catch (OperationCanceledException)
            {
            }
        }
        if (_systemPollTask != null)
        {
            try
            {
                await _systemPollTask;
            }
            catch (OperationCanceledException)
            {
            }
        }
        _pollCts?.Dispose();
        _systemPollCts?.Dispose();
    }

    private static string? GetProfileName(JsonElement profile)
    {
        if (profile.TryGetProperty("Name", out var nameProp))
        {
            return nameProp.GetString();
        }
        if (profile.TryGetProperty("name", out var namePropLower))
        {
            return namePropLower.GetString();
        }
        return null;
    }

    private static string GetTaskLabel(QueueItemView item)
    {
        switch (item.Mode)
        {
            case ProcMode.Batch:
                return "通常";
            case ProcMode.CMCheck:
                return "CM解析のみ";
            case ProcMode.DrcsCheck:
                return "DRCSチェック";
            case ProcMode.Test:
                return "テスト";
            case ProcMode.AutoBatch:
                return "自動追加";
        }
        return "不明";
    }

    private static string GetBroadcastDateShort(QueueItemView item)
    {
        var timeText = item.DisplayBroadcastTime;
        if (string.IsNullOrEmpty(timeText))
        {
            var time = item.EitStartTime ?? item.TsTime ?? item.EncodeStart;
            timeText = time.HasValue ? time.Value.ToString("MM/dd") : (item.DisplayEncodeStart ?? "-");
        }
        if (string.IsNullOrEmpty(timeText))
        {
            return "-";
        }
        if (DateTime.TryParse(timeText, out var parsed))
        {
            return parsed.ToString("MM/dd");
        }
        if (timeText.Length >= 5 && timeText.Contains('-'))
        {
            var parts = timeText.Split('-', '/', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 3)
            {
                return $"{parts[1]}/{parts[2]}";
            }
        }
        return timeText;
    }

    private static string GetBroadcastChannel(QueueItemView item)
    {
        return string.IsNullOrEmpty(item.ServiceName) ? "-" : item.ServiceName!;
    }

    private static string ToHalfWidth(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }
        var chars = value.ToCharArray();
        for (var i = 0; i < chars.Length; i++)
        {
            var c = chars[i];
            if (c == '\u3000')
            {
                chars[i] = ' ';
                continue;
            }
            if (c >= '\uFF01' && c <= '\uFF5E')
            {
                chars[i] = (char)(c - 0xFEE0);
            }
        }
        return new string(chars);
    }

    private static string GetInputFolder(QueueItemView item)
    {
        var dirPath = item.DirName;
        if (!string.IsNullOrEmpty(dirPath))
        {
            var trimmed = dirPath.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
            var leaf = Path.GetFileName(trimmed);
            return string.IsNullOrEmpty(leaf) ? dirPath : leaf;
        }

        var path = item.SrcPath ?? item.FileName ?? "";
        if (string.IsNullOrEmpty(path))
        {
            return "-";
        }
        var dir = Path.GetDirectoryName(path);
        if (string.IsNullOrEmpty(dir))
        {
            return "-";
        }
        return Path.GetFileName(dir) ?? dir;
    }

    private static string GetInputFile(QueueItemView item)
    {
        var path = item.SrcPath ?? item.FileName ?? "";
        if (string.IsNullOrEmpty(path))
        {
            return "-";
        }
        return Path.GetFileName(path);
    }

    private static string BuildQueueTooltip(QueueItemView item)
    {
        var fullPath = item.SrcPath ?? item.FileName ?? "-";
        var genreText = item.GenreNames == null || item.GenreNames.Count == 0
            ? "-"
            : string.Join(" / ", item.GenreNames);
        var sizeText = (item.ImageWidth > 0 && item.ImageHeight > 0)
            ? $"{item.ImageWidth}x{item.ImageHeight}"
            : "-";
        var tagText = item.Tags == null || item.Tags.Count == 0
            ? "-"
            : string.Join(", ", item.Tags);
        var outDir = string.IsNullOrEmpty(item.OutDir) ? "-" : item.OutDir;

        return $"フルパス: {fullPath}\nジャンル: {genreText}\n映像サイズ: {sizeText}\nタグ: {tagText}\n出力先: {outDir}";
    }
    private static string GetStateText(QueueItemView item)
    {
        var baseText = item.StateLabel ?? item.State ?? "-";
        if (string.Equals(item.State, "Complete", StringComparison.OrdinalIgnoreCase)
            || string.Equals(item.StateLabel, "完了", StringComparison.Ordinal))
        {
            if (item.EncodeStart.HasValue && item.EncodeFinish.HasValue)
            {
                var duration = item.EncodeFinish.Value - item.EncodeStart.Value;
                var finish = item.DisplayEncodeFinish ?? item.EncodeFinish.Value.ToString("yyyy-MM-dd HH:mm");
                return $"{baseText} ({duration:hh\\:mm\\:ss} / {finish})";
            }
        }
        return baseText;
    }

    private async Task CopyProfileAsync(QueueItemView item)
    {
        _actionMessage = null;
        _error = null;
        var targetName = item.ProfileName;
        if (string.IsNullOrWhiteSpace(targetName))
        {
            _error = "Profile name is empty.";
            return;
        }

        var profile = _profiles.FirstOrDefault(p => string.Equals(GetProfileName(p), targetName, StringComparison.OrdinalIgnoreCase));
        if (profile.ValueKind == JsonValueKind.Undefined)
        {
            _error = "Profile not found.";
            return;
        }

        var text = profile.GetRawText();
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            _actionMessage = "Profile copied to clipboard.";
        }
        catch
        {
            _error = "Failed to copy to clipboard.";
        }
    }

    private Task RetryAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ResetState);

    private Task ReapplyProfileAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.UpdateProfile);

    private Task CancelAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.Cancel);

    private Task DeleteAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.RemoveItem);

    private Task ForceStartAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ForceStart);

    private async Task OpenLogoAnalyzeAsync(QueueItemView item)
    {
        var url = $"logo-analyze?queueItemId={item.Id}";
        var absoluteUrl = Nav.ToAbsoluteUri(url).ToString();
        await JS.InvokeVoidAsync("amatsukazeUi.openInNewTab", absoluteUrl);
    }

    private async Task ChangePriorityAsync(QueueItemView item)
    {
        if (!_priorityInputs.TryGetValue(item.Id, out var priority))
        {
            priority = item.Priority;
        }
        priority = ClampPriority(priority);
        _priorityInputs[item.Id] = priority;
        await ChangeItemAsync(item, ChangeItemType.Priority, priority: priority);
    }

    private async Task ChangeProfileAsync(QueueItemView item)
    {
        if (!_profileInputs.TryGetValue(item.Id, out var profile) || string.IsNullOrWhiteSpace(profile))
        {
            _error = "Profile name is required.";
            return;
        }
        await ChangeItemAsync(item, ChangeItemType.Profile, profile: profile);
    }

    private async Task ChangeItemAsync(QueueItemView item, ChangeItemType type, int? priority = null, string? profile = null, int? position = null)
    {
        var ok = await SendChangeAsync(item.Id, type, priority, profile, position);
        if (ok)
        {
            _actionMessage = "Operation completed.";
            await SyncAfterMutationAsync();
        }
    }

    private async Task<bool> SendChangeAsync(int itemId, ChangeItemType type, int? priority = null, string? profile = null, int? position = null)
    {
        _actionMessage = null;
        _error = null;
        var req = new ChangeItemData
        {
            ItemId = itemId,
            ChangeType = type,
            Priority = priority ?? 0,
            Profile = profile,
            Position = position ?? 0
        };
        var res = await Api.ChangeQueueAsync(req);
        if (!res.Ok)
        {
            _error = res.Error ?? "Operation failed.";
            return false;
        }
        return true;
    }

    private async Task ExecuteSelectedAsync(ChangeItemType type, string label)
    {
        CloseContextMenu();
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }
        var targets = _view.Items.Where(x => _selectedIds.Contains(x.Id)).ToList();
        if (targets.Count == 0)
        {
            return;
        }
        var anyError = false;
        foreach (var item in targets)
        {
            var ok = await SendChangeAsync(item.Id, type);
            if (!ok)
            {
                anyError = true;
                break;
            }
        }
        if (!anyError)
        {
            _actionMessage = $"{label} を実行しました。";
        }
        await ReloadAsync();
    }

    private async Task OpenLogoAnalyzeSelectedAsync()
    {
        CloseContextMenu();
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }
        var item = _view.Items.FirstOrDefault(x => _selectedIds.Contains(x.Id));
        if (item == null)
        {
            return;
        }
        await OpenLogoAnalyzeAsync(item);
    }

    private async Task ClearSucceededAsync()
    {
        CloseContextMenu();
        var ok = await SendChangeAsync(0, ChangeItemType.RemoveCompleted);
        if (ok)
        {
            _actionMessage = "成功済みをクリアしました。";
            await ReloadAsync();
        }
    }

    private void OnRowClick(QueueItemView item, MouseEventArgs e)
    {
        CloseContextMenu();
        if (e.ShiftKey)
        {
            SelectRange(item.Id, additive: e.CtrlKey);
            return;
        }
        if (e.CtrlKey)
        {
            if (_selectedIds.Contains(item.Id))
            {
                _selectedIds.Remove(item.Id);
            }
            else
            {
                _selectedIds.Add(item.Id);
            }
            _selectionAnchorId = item.Id;
            return;
        }
        if (_selectedIds.Contains(item.Id))
        {
            _selectionAnchorId = item.Id;
            return;
        }
        _selectedIds.Clear();
        _selectedIds.Add(item.Id);
        _selectionAnchorId = item.Id;
    }

    private async Task OnRowContextMenu(QueueItemView item, MouseEventArgs e)
    {
        if (!_selectedIds.Contains(item.Id))
        {
            _selectedIds.Clear();
            _selectedIds.Add(item.Id);
        }
        _selectionAnchorId = item.Id;
        _contextMenuX = e.ClientX;
        var viewportHeight = await JS.InvokeAsync<double>("amatsukazeUi.getViewportHeight");
        if (viewportHeight > 0 && e.ClientY + ContextMenuHeight + ContextMenuMargin > viewportHeight)
        {
            _contextMenuY = Math.Max(ContextMenuMargin, e.ClientY - ContextMenuHeight);
        }
        else
        {
            _contextMenuY = e.ClientY;
        }
        _contextMenuVisible = true;
    }

    private async Task OpenConsoleSelected()
    {
        if (_selectedIds.Count == 0)
        {
            return;
        }
        var taskId = _selectedIds.First();
        CloseContextMenu();
        var absoluteUrl = Nav.ToAbsoluteUri($"/console/{taskId}").ToString();
        await JS.InvokeVoidAsync("amatsukazeUi.openInNewTab", absoluteUrl);
    }

    private void CloseContextMenu()
    {
        _contextMenuVisible = false;
    }

    private string GetRowClass(QueueItemView item, int rowIndex)
    {
        var classes = new List<string> { "queue-row", GetStateClass(item) };
        if (_selectedIds.Contains(item.Id))
        {
            classes.Add("is-selected");
            if (_isDragging)
            {
                classes.Add("is-dragging");
            }
        }
        if (_dropIndex == rowIndex)
        {
            classes.Add("queue-drop-target");
        }
        return string.Join(" ", classes.Where(c => !string.IsNullOrWhiteSpace(c)));
    }

    private static string GetStateClass(QueueItemView item)
    {
        var state = item.State ?? string.Empty;
        if (string.IsNullOrWhiteSpace(state))
        {
            state = item.StateLabel ?? string.Empty;
        }
        if (state.Equals("Encoding", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-encoding";
        }
        if (state.Equals("Failed", StringComparison.OrdinalIgnoreCase) || state.Equals("PreFailed", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-error";
        }
        if (state.Equals("Queue", StringComparison.OrdinalIgnoreCase) || state.Equals("LogoPending", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-pending";
        }
        if (state.Equals("Canceled", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-canceled";
        }
        if (state.Equals("Complete", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-complete";
        }
        if (state.Contains("エンコード", StringComparison.Ordinal))
        {
            return "queue-state-encoding";
        }
        if (state.Contains("失敗", StringComparison.Ordinal))
        {
            return "queue-state-error";
        }
        if (state.Contains("ペンディング", StringComparison.Ordinal) || state.Contains("待ち", StringComparison.Ordinal))
        {
            return "queue-state-pending";
        }
        if (state.Contains("キャンセル", StringComparison.Ordinal))
        {
            return "queue-state-canceled";
        }
        if (state.Contains("完了", StringComparison.Ordinal))
        {
            return "queue-state-complete";
        }
        return string.Empty;
    }

    private async Task MoveSelectedItemsAsync(int dropIndex)
    {
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }

        var selectedIds = _view.Items
            .Where(item => _selectedIds.Contains(item.Id))
            .Select(item => item.Id)
            .ToList();

        if (selectedIds.Count == 0)
        {
            return;
        }

        _actionMessage = null;
        _error = null;

        var req = new QueueMoveManyRequest
        {
            ItemIds = selectedIds,
            DropIndex = dropIndex
        };

        var res = await Api.MoveQueueManyAsync(req);
        if (!res.Ok)
        {
            _error = res.Error ?? "Operation failed.";
            return;
        }

        _actionMessage = "Operation completed.";
        await SyncAfterMutationAsync();
    }

    private async Task SyncAfterMutationAsync()
    {
        await PollOnceAsyncCore(preserveScrollOnFullSync: true);
    }

    private void SelectRange(int itemId, bool additive)
    {
        if (!_filteredIndexById.TryGetValue(itemId, out var endIndex))
        {
            if (!additive)
            {
                _selectedIds.Clear();
            }
            _selectedIds.Add(itemId);
            _selectionAnchorId = itemId;
            return;
        }

        var anchorId = _selectionAnchorId ?? itemId;
        if (!_filteredIndexById.TryGetValue(anchorId, out var startIndex))
        {
            startIndex = endIndex;
            anchorId = itemId;
        }

        if (!additive)
        {
            _selectedIds.Clear();
        }

        var lower = Math.Min(startIndex, endIndex);
        var upper = Math.Max(startIndex, endIndex);
        for (var i = lower; i <= upper; i++)
        {
            _selectedIds.Add(_filteredItems[i].Id);
        }
        _selectionAnchorId = anchorId;
    }

    private async Task OnQueueDrop()
    {
        if (_view == null)
        {
            return;
        }
        var visualDropIndex = _dropIndex;
        _dropIndex = -1;
        var dragId = await JS.InvokeAsync<int>("amatsukazeDnd.getDragId");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearDragId");
        if (dragId < 0 || !_indexById.TryGetValue(dragId, out var fromIndex))
        {
            return;
        }

        // ドラッグ元アイテムを選択に含める
        var draggedItem = _view.Items[fromIndex];
        if (!_selectedIds.Contains(draggedItem.Id))
        {
            _selectedIds.Clear();
            _selectedIds.Add(draggedItem.Id);
            _selectionAnchorId = draggedItem.Id;
        }

        var dropIndex = ResolveDropIndexFromVisual(visualDropIndex);
        if (dropIndex < 0)
        {
            return;
        }

        // 複数選択の場合
        if (_selectedIds.Count > 1)
        {
            await MoveSelectedItemsAsync(dropIndex);
            return;
        }

        // 単一選択の場合（従来の処理）
        var toIndex = dropIndex;
        if (toIndex > fromIndex)
        {
            toIndex -= 1;
        }
        if (toIndex < 0)
        {
            toIndex = 0;
        }
        if (toIndex >= _view.Items.Count)
        {
            toIndex = _view.Items.Count - 1;
        }
        if (toIndex == fromIndex)
        {
            return;
        }
        await ChangeItemAsync(draggedItem, ChangeItemType.Move, position: toIndex);
    }

    private int ResolveDropIndexFromVisual(int visualDropIndex)
    {
        if (_view == null)
        {
            return -1;
        }
        if (_filteredItems.Count == 0)
        {
            return _view.Items.Count;
        }
        if (visualDropIndex <= 0)
        {
            var firstVisibleId = _filteredItems[0].Id;
            return _indexById.TryGetValue(firstVisibleId, out var firstIndex) ? firstIndex : -1;
        }
        if (visualDropIndex >= _filteredItems.Count)
        {
            var lastVisibleId = _filteredItems[_filteredItems.Count - 1].Id;
            return _indexById.TryGetValue(lastVisibleId, out var lastIndex) ? lastIndex + 1 : -1;
        }
        var nextVisibleId = _filteredItems[visualDropIndex].Id;
        return _indexById.TryGetValue(nextVisibleId, out var nextIndex) ? nextIndex : -1;
    }

    private Task OnQueueDropFromBody()
    {
        return Task.CompletedTask;
    }

    private async Task OnQueueDropFromRow()
    {
        var lastDropId = await JS.InvokeAsync<int>("amatsukazeDnd.getLastDropId");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearLastDropId");
        if (lastDropId != -999)
        {
            await OnQueueDrop();
        }
    }

    private void OnQueueDragEnter(int index)
    {
        _dropIndex = index;
        _isDragging = true;
    }

    private void OnQueueBodyDragEnter()
    {
        if (_view == null)
        {
            return;
        }
        if (_dropIndex < 0)
        {
            _dropIndex = _filteredItems.Count;
        }
    }

    private async Task OnQueueDragEnd()
    {
        _isDragging = false;
        var lastDropId = await JS.InvokeAsync<int>("amatsukazeDnd.getLastDropId");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearLastDropId");
        if (_view == null)
        {
            _dropIndex = -1;
            await JS.InvokeVoidAsync("amatsukazeDnd.clearDragId");
            return;
        }
        if (lastDropId != -999)
        {
            await OnQueueDrop();
        }
        _dropIndex = -1;
        await JS.InvokeVoidAsync("amatsukazeDnd.clearDragId");
    }


    private string GetDropRowClass()
        => _dropIndex == _filteredItems.Count ? "queue-drop-row queue-drop-target" : "queue-drop-row";

    private async Task OnToggleQueuePause(ChangeEventArgs e)
    {
        if (_system?.State == null || _pauseBusy)
        {
            return;
        }
        _pauseBusy = true;
        var desiredRunning = GetBoolValue(e.Value);
        var req = new PauseRequest
        {
            IsQueue = true,
            Pause = !desiredRunning
        };
        var res = await Api.PauseQueueAsync(req);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _pauseBusy = false;
    }

    private async Task OnToggleEncoderSuspend(ChangeEventArgs e)
    {
        if (_system?.State == null || _suspendBusy)
        {
            return;
        }
        _suspendBusy = true;
        var desiredOk = GetBoolValue(e.Value);
        var req = new PauseRequest
        {
            IsQueue = false,
            Index = -1,
            Pause = !desiredOk
        };
        var res = await Api.PauseQueueAsync(req);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _suspendBusy = false;
    }

    private async Task OnFinishActionChanged(ChangeEventArgs e)
    {
        if (_system?.FinishSetting == null || _finishBusy)
        {
            return;
        }
        var value = e.Value?.ToString() ?? "";
        if (string.IsNullOrWhiteSpace(value) || value == _system.FinishSetting.Action)
        {
            return;
        }
        _finishBusy = true;
        var setting = new FinishSetting
        {
            Action = value,
            Seconds = _system.FinishSetting.Seconds,
            NoActionExe = _system.FinishSetting.NoActionExe,
            NoActionExeList = _system.FinishSetting.NoActionExeList != null
                ? new List<string>(_system.FinishSetting.NoActionExeList)
                : null
        };
        var res = await Api.UpdateFinishSettingAsync(setting);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _finishBusy = false;
    }

    private static bool GetBoolValue(object? value)
    {
        if (value is bool b)
        {
            return b;
        }
        if (value is string s && bool.TryParse(s, out var parsed))
        {
            return parsed;
        }
        return false;
    }

    private static int ClampPriority(int priority)
        => Math.Clamp(priority, MinPriority, MaxPriority);
}
