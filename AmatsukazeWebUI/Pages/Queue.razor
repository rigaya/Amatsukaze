@page "/"
@page "/queue"
@using Amatsukaze.Shared
@using System.Text.Json
@using System.Threading
@using System.IO
@using System.Linq
@inject IAmatsukazeApi Api
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IAsyncDisposable

<h3>キュー</h3>

<style>
    .status-toggle {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
        vertical-align: middle;
    }
    .status-toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .status-toggle .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .2s;
        border-radius: 12px;
    }
    .status-toggle .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .2s;
        border-radius: 50%;
    }
    .status-toggle input:checked + .slider {
        background-color: #4caf50;
    }
    .status-toggle input:checked + .slider:before {
        transform: translateX(20px);
    }
    .status-toggle input:disabled + .slider {
        background-color: #999;
        cursor: not-allowed;
    }
</style>

<div class="queue-header">
    <button class="btn btn-primary" @onclick="ReloadAsync" disabled="@_loading">更新</button>
    <button class="btn btn-success" @onclick="OpenAddDialogAsync">タスク追加</button>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>キュー</span>
        <span class="queue-header-group-body">
            <span class="status-toggle">
                <input type="checkbox"
                       checked="@IsQueueRunning"
                       disabled="@(_pauseBusy || _system?.State == null)"
                       @onchange="OnToggleQueuePause" />
                <span class="slider"></span>
            </span>
            <span class="queue-header-state">@(_system?.State == null ? "-" : (IsQueueRunning ? "稼働中" : "停止"))</span>
        </span>
    </label>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>エンコーダ</span>
        <span class="queue-header-group-body">
            <span class="status-toggle">
                <input type="checkbox"
                       checked="@IsEncoderOk"
                       disabled="@(_suspendBusy || _system?.State == null)"
                       @onchange="OnToggleEncoderSuspend" />
                <span class="slider"></span>
            </span>
            <span class="queue-header-state">@(_system?.State == null ? "-" : (IsEncoderOk ? "OK" : "一時停止"))</span>
        </span>
    </label>
    <span class="queue-header-sep" aria-hidden="true"></span>

    <label class="queue-header-group">
        <span>処理後</span>
        <span class="queue-header-group-body">
            <select class="form-select queue-finish-select" style="width: 180px;"
                    value="@_finishAction"
                    disabled="@(_finishBusy || _system?.FinishSetting == null)"
                    @onchange="OnFinishActionChanged">
                @if (_finishActionOptions.Count == 0)
                {
                    <option value="">-</option>
                }
                else
                {
                    @foreach (var option in _finishActionOptions)
                    {
                        <option value="@option.Value">@option.Label</option>
                    }
                }
            </select>
        </span>
    </label>
</div>

@if (_loading)
{
    <p>Loading...</p>
}
else if (!string.IsNullOrEmpty(_error))
{
    <p style="color: red;">@_error</p>
}
else if (_view == null)
{
    <p>No data.</p>
}
else
{
    if (!string.IsNullOrEmpty(_actionMessage))
    {
        <p style="color: green;">@_actionMessage</p>
    }

    <div>
        <strong>Counters</strong>
        <div>
            Active: @_view.Counters.Active /
            Encoding: @_view.Counters.Encoding /
            Complete: @_view.Counters.Complete /
            Pending: @_view.Counters.Pending /
            Failed: @_view.Counters.Failed /
            Canceled: @_view.Counters.Canceled
        </div>
    </div>

    <h4>項目</h4>
    @if (_view.Items.Count == 0)
    {
        <p>No queue items.</p>
    }
    else
    {
        <div class="queue-list"
             data-drop-end="true"
             ondragover="return amatsukazeDnd.updateDropIndexFromEvent(event)"
             @onclick="CloseContextMenu"
             @ondragenter="OnQueueBodyDragEnter">
        <table class="table queue-table"
               data-drop-end="true"
               ondragover="return amatsukazeDnd.updateDropIndexFromEvent(event)"
               @ondragenter="OnQueueBodyDragEnter">
            <thead>
                <tr>
                    <th>タスク<br>放送日 / チャンネル</th>
                    <th>入力ファイル</th>
                    <th>プロファイル<br>状態 / 優先度</th>
                </tr>
            </thead>
            <tbody @ondragover:preventDefault="true"
                   @ondrop:preventDefault="true"
                   @ondrop="OnQueueDropFromBody"
                   @ondragenter="OnQueueBodyDragEnter"
                   @ondragend="OnQueueDragEnd"
                   >
                @for (var i = 0; i < _view.Items.Count; i++)
                {
                    var rowIndex = i;
                    var item = _view.Items[rowIndex];
                    <tr @key="item.Id"
                        class="@GetRowClass(item, rowIndex)"
                        draggable="true"
                        data-queue-index="@rowIndex"
                        ondragstart="return amatsukazeDnd.setDataWithIndex(event)"
                        ondragover="return amatsukazeDnd.updateDropIndexFromEvent(event)"
                        @ondragenter="(() => OnQueueDragEnter(rowIndex))"
                        @ondragend="OnQueueDragEnd"
                        @onclick="(e => OnRowClick(item, e))"
                        @onclick:stopPropagation="true"
                        @oncontextmenu="(e => OnRowContextMenu(item, e))"
                        @oncontextmenu:preventDefault="true"
                        @oncontextmenu:stopPropagation="true"
                        @ondrop:preventDefault="true"
                        @ondrop="@(() => OnQueueDrop(rowIndex))">
                        <td>
                            <div class="queue-cell-stack">
                                <div class="queue-cell-line queue-task">@GetTaskLabel(item)</div>
                                <div class="queue-cell-line queue-channel">@GetBroadcastDateShort(item) @@ @ToHalfWidth(GetBroadcastChannel(item))</div>
                            </div>
                        </td>
                        <td class="queue-input-file" title="@BuildQueueTooltip(item)">@GetInputFile(item)</td>
                        <td class="queue-actions-cell">
                            <div class="queue-cell-stack">
                                <div class="queue-cell-line">
                                    <select class="queue-profile-select"
                                            @bind="_profileInputs[item.Id]"
                                            @bind:after="(() => ChangeProfileAsync(item))">
                                        <option value="">(Profile)</option>
                                        @foreach (var name in _profileNames)
                                        {
                                            <option value="@name">@name</option>
                                        }
                                    </select>
                                </div>
                                <div class="queue-cell-line queue-state-priority">
                                    <span class="queue-state">@GetStateText(item)</span>
                                    <input type="number" class="queue-priority-input"
                                           @bind="_priorityInputs[item.Id]"
                                           @bind:after="(() => ChangePriorityAsync(item))" />
                                </div>
                            </div>
                        </td>
                    </tr>
                }
                <tr class="@GetDropRowClass()"
                    data-drop-end="true"
                    ondragover="return amatsukazeDnd.onOverWithIndex(event)"
                    @ondragenter="(() => OnQueueDragEnter(_view.Items.Count))"
                    @ondragend="OnQueueDragEnd">
                    <td colspan="3"></td>
                </tr>
            </tbody>
        </table>
        @if (_contextMenuVisible)
        {
            <div class="queue-context-menu"
                 style="left: @_contextMenuXpx; top: @_contextMenuYpx;"
                 @onclick:stopPropagation="true">
                <button class="queue-menu-item" @onclick="OpenConsoleSelected">コンソール</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.ResetState, "リトライ"))' disabled="@(!_hasSelection)">リトライ</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.UpdateProfile, "プロファイル再適用"))' disabled="@(!_hasSelection)">プロファイル再適用</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.Cancel, "キャンセル"))' disabled="@(!_hasSelection)">キャンセル</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.RemoveItem, "削除"))' disabled="@(!_hasSelection)">削除</button>
                <button class="queue-menu-item" @onclick='(() => ExecuteSelectedAsync(ChangeItemType.ForceStart, "強制実行"))' disabled="@(!_hasSelection)">強制実行</button>
                <button class="queue-menu-item" @onclick="(() => OpenLogoAnalyzeSelectedAsync())" disabled="@(!_hasSelection)">ロゴ解析</button>
                <button class="queue-menu-item" @onclick="ClearSucceededAsync">成功済みをクリア</button>
            </div>
        }
        </div>
    }
}

@if (_showAddDialog)
{
    <div class="modal-overlay" @onclick="CloseAddDialog">
        <div class="modal-body" @onclick:stopPropagation="true">
            <h4>キュー追加</h4>
            @if (!string.IsNullOrEmpty(_addError))
            {
                <p style="color: red;">@_addError</p>
            }
            <div class="form-row">
                <label>Input TS</label>
                <PathSuggestInput Value="@_addSrcPath"
                                  ValueChanged="OnAddSrcPathChanged"
                                  Placeholder="*.ts"
                                  Extensions=".ts"
                                  AllowFiles="true"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="20" />
            </div>
            <div class="form-row">
                <label>Profile</label>
                <select class="form-select" @bind="_addProfile">
                    <option value="">(Select)</option>
                    @foreach (var name in _profileNames)
                    {
                        <option value="@name">@name</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Output Dir</label>
                <PathSuggestInput Value="@_addOutDir"
                                  ValueChanged="OnAddOutDirChanged"
                                  Placeholder="/path/to/output"
                                  AllowFiles="false"
                                  AllowDirs="true"
                                  MaxDirs="10"
                                  MaxFiles="20" />
            </div>
            <div class="form-row">
                <label>Priority</label>
                <select class="form-select" @bind="_addPriority">
                    @foreach (var p in QueueSettingExtensions.PriorityList)
                    {
                        <option value="@p">@p</option>
                    }
                </select>
            </div>
            <div class="form-row">
                <label>追加時バッチ</label>
                <select class="form-select" @bind="_addAddQueueBat">
                    <option value="">(None)</option>
                    @if (_addQueueBatFiles != null)
                    {
                        @foreach (var name in _addQueueBatFiles)
                        {
                            <option value="@name">@name</option>
                        }
                    }
                </select>
            </div>
            <div class="form-row">
                <label>Mode</label>
                <select class="form-select" @bind="_addMode">
                    @foreach (var mode in QueueSettingExtensions.QueueProcModes)
                    {
                        <option value="@mode">@QueueSettingExtensions.GetProcModeDisplay(mode)</option>
                    }
                </select>
            </div>
            <div style="margin-top: 1rem;">
                <button class="btn btn-primary" @onclick="SubmitAddQueueAsync" disabled="@_adding">Add</button>
                <button class="btn btn-secondary" style="margin-left: 0.5rem;" @onclick="CloseAddDialog" disabled="@_adding">Cancel</button>
            </div>
        </div>
    </div>
}

@code {
    private QueueView? _view;
    private SystemSnapshot? _system;
    private string? _error;
    private string? _systemError;
    private bool _loading = true;
    private string? _actionMessage;
    private readonly Dictionary<int, string?> _profileInputs = new();
    private readonly Dictionary<int, int> _priorityInputs = new();
    private readonly List<JsonElement> _profiles = new();
    private readonly List<string> _profileNames = new();
    private readonly HashSet<int> _selectedIds = new();
    private bool _contextMenuVisible;
    private double _contextMenuX;
    private double _contextMenuY;
    private int _dropIndex = -1;
    private bool _isDragging;
    private CancellationTokenSource? _pollCts;
    private Task? _pollTask;
    private long _queueVersion;
    private string? _queueDigest;
    private bool _polling;
    private bool _systemPolling;
    private CancellationTokenSource? _systemPollCts;
    private Task? _systemPollTask;
    private bool _pauseBusy;
    private bool _suspendBusy;
    private bool _finishBusy;
    private readonly List<FinishActionOptionView> _finishActionOptions = new();
    private string _finishAction = "";
    private bool _showAddDialog;
    private string? _addError;
    private bool _adding;
    private string _addSrcPath = "";
    private string _addOutDir = "";
    private string _addProfile = "";
    private int _addPriority = 3;
    private string _addAddQueueBat = "";
    private ProcMode _addMode = ProcMode.Batch;
    private List<string>? _addQueueBatFiles;
    private UiStateView? _uiState;
    private bool _hasSelection => _selectedIds.Count > 0;
    private string _contextMenuXpx => $"{_contextMenuX:0}px";
    private string _contextMenuYpx => $"{_contextMenuY:0}px";

    private bool IsQueueRunning => _system?.State != null && !_system.State.Pause;
    private bool IsEncoderOk => _system?.State != null && !_system.State.Suspend;

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
        await ReloadSystemAsync();
        StartPolling();
        StartSystemPolling();
    }

    private bool IsAddValid =>
        !string.IsNullOrWhiteSpace(_addSrcPath) &&
        !string.IsNullOrWhiteSpace(_addProfile) &&
        !string.IsNullOrWhiteSpace(_addOutDir);

    private async Task ReloadAsync()
    {
        _loading = true;
        _error = null;
        _actionMessage = null;
        _view = null;
        _profiles.Clear();
        _profileNames.Clear();

        var queueTask = Api.GetQueueAsync();
        var profilesTask = Api.GetProfilesAsync();

        await Task.WhenAll(queueTask, profilesTask);

        var res = await queueTask;
        var profilesRes = await profilesTask;

        if (!profilesRes.Ok)
        {
            _error = profilesRes.Error ?? "Failed to load profiles.";
        }
        else if (profilesRes.Data != null)
        {
            _profiles.AddRange(profilesRes.Data);
            foreach (var profile in _profiles)
            {
                var name = GetProfileName(profile);
                if (!string.IsNullOrEmpty(name))
                {
                    _profileNames.Add(name);
                }
            }
        }

        if (!res.Ok && string.IsNullOrEmpty(_error))
        {
            _error = res.Error ?? "Failed to load queue.";
        }
        else
        {
            _view = res.Data;
            if (_view != null)
            {
                _queueVersion = _view.Version;
                _queueDigest = _view.Digest;
                foreach (var item in _view.Items)
                {
                    if (!_profileInputs.ContainsKey(item.Id))
                    {
                        _profileInputs[item.Id] = item.ProfileName ?? "";
                    }
                    if (!_priorityInputs.ContainsKey(item.Id))
                    {
                        _priorityInputs[item.Id] = item.Priority;
                    }
                }
                if (_selectedIds.Count > 0)
                {
                    var ids = _view.Items.Select(x => x.Id).ToHashSet();
                    _selectedIds.RemoveWhere(id => !ids.Contains(id));
                }
            }
        }

        _loading = false;
    }

    private async Task ReloadSystemAsync()
    {
        var res = await Api.GetSystemAsync();
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to load system status.";
            return;
        }
        _systemError = null;
        _system = res.Data;
        _finishActionOptions.Clear();
        if (_system?.FinishActionOptions != null)
        {
            _finishActionOptions.AddRange(_system.FinishActionOptions);
        }
        _finishAction = _system?.FinishSetting?.Action ?? "";
    }

    private void StartSystemPolling()
    {
        _systemPollCts?.Cancel();
        _systemPollCts = new CancellationTokenSource();
        var token = _systemPollCts.Token;
        _systemPollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollSystemOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private async Task PollSystemOnceAsync()
    {
        if (_loading || _systemPolling)
        {
            return;
        }
        _systemPolling = true;
        try
        {
            await ReloadSystemAsync();
        }
        finally
        {
            _systemPolling = false;
            StateHasChanged();
        }
    }

    private async Task OpenAddDialogAsync()
    {
        _addError = null;
        _showAddDialog = true;
        await EnsureAddDialogDataAsync();
        StateHasChanged();
    }

    private void CloseAddDialog()
    {
        _showAddDialog = false;
        _addError = null;
    }

    private async Task EnsureAddDialogDataAsync()
    {
        if (_addQueueBatFiles == null)
        {
            var optionsRes = await Api.GetProfileOptionsAsync();
            if (optionsRes.Ok)
            {
                _addQueueBatFiles = optionsRes.Data?.PreBatFiles;
            }
        }

        if (_profileNames.Count == 0)
        {
            var profilesRes = await Api.GetProfilesAsync();
            if (profilesRes.Ok && profilesRes.Data != null)
            {
                _profiles.Clear();
                _profileNames.Clear();
                _profiles.AddRange(profilesRes.Data);
                foreach (var profile in _profiles)
                {
                    var name = GetProfileName(profile);
                    if (!string.IsNullOrEmpty(name))
                    {
                        _profileNames.Add(name);
                    }
                }
            }
        }

        if (_uiState == null)
        {
            var uiRes = await Api.GetUiStateAsync();
            if (uiRes.Ok)
            {
                _uiState = uiRes.Data;
            }
        }

        if (string.IsNullOrWhiteSpace(_addProfile))
        {
            _addProfile = _uiState?.LastUsedProfile ?? "";
        }
        if (string.IsNullOrWhiteSpace(_addProfile) && _profileNames.Count > 0)
        {
            _addProfile = _profileNames[0];
        }

        if (string.IsNullOrWhiteSpace(_addOutDir))
        {
            _addOutDir = _uiState?.LastOutputPath ?? "";
        }

        if (string.IsNullOrWhiteSpace(_addAddQueueBat))
        {
            _addAddQueueBat = _uiState?.LastAddQueueBat ?? "";
        }
    }

    private Task OnAddSrcPathChanged(string value)
    {
        _addSrcPath = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnAddOutDirChanged(string value)
    {
        _addOutDir = value?.Trim() ?? "";
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task SubmitAddQueueAsync()
    {
        if (!IsAddValid)
        {
            _addError = "Required fields are missing.";
            return;
        }

        _adding = true;
        _addError = null;
        try
        {
            var dirPath = GetParentDir(_addSrcPath);
            var outDir = NormalizeOutputDir(_addOutDir);
            if (string.IsNullOrWhiteSpace(outDir))
            {
                _addError = "Output directory is invalid.";
                return;
            }
            var req = new AddQueueRequest
            {
                DirPath = dirPath,
                Targets = new List<AddQueueItem>
                {
                    new AddQueueItem { Path = _addSrcPath }
                },
                Outputs = new List<OutputInfo>
                {
                    new OutputInfo
                    {
                        DstPath = outDir,
                        Profile = _addProfile,
                        Priority = _addPriority
                    }
                },
                Mode = _addMode,
                AddQueueBat = string.IsNullOrWhiteSpace(_addAddQueueBat) ? null : _addAddQueueBat
            };

            var res = await Api.AddQueueAsync(req);
            if (!res.Ok)
            {
                _addError = TryExtractServerError(res.Error) ?? res.Error ?? "Failed to add queue item.";
                return;
            }
            _showAddDialog = false;
            await ReloadAsync();
        }
        finally
        {
            _adding = false;
        }
    }

    private static string GetParentDir(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return "";
        }
        var lastSlash = Math.Max(path.LastIndexOf('/'), path.LastIndexOf('\\'));
        if (lastSlash <= 0)
        {
            return "";
        }
        return path.Substring(0, lastSlash);
    }

    private static string NormalizeOutputDir(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return "";
        }
        var trimmed = path.Trim();
        if (trimmed.EndsWith("/") || trimmed.EndsWith("\\"))
        {
            return trimmed.TrimEnd('/', '\\');
        }
        if (Path.HasExtension(trimmed))
        {
            var dir = GetParentDir(trimmed);
            return dir;
        }
        return trimmed;
    }

    private static string? TryExtractServerError(string? error)
    {
        if (string.IsNullOrWhiteSpace(error))
        {
            return null;
        }
        try
        {
            using var doc = JsonDocument.Parse(error);
            if (doc.RootElement.TryGetProperty("error", out var errProp))
            {
                var msg = errProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
            if (doc.RootElement.TryGetProperty("detail", out var detailProp))
            {
                var msg = detailProp.GetString();
                return string.IsNullOrWhiteSpace(msg) ? null : msg;
            }
        }
        catch
        {
        }
        return null;
    }

    private void StartPolling()
    {
        _pollCts?.Cancel();
        _pollCts = new CancellationTokenSource();
        var token = _pollCts.Token;
        _pollTask = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(PollOnceAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private async Task PollOnceAsync()
    {
        if (_loading || _view == null || _polling)
        {
            return;
        }
        _polling = true;
        try
        {
            var res = await Api.GetQueueChangesAsync(_queueVersion);
            if (!res.Ok)
            {
                _error = res.Error ?? "Failed to poll queue.";
                return;
            }
            var data = res.Data;
            if (data == null)
            {
                return;
            }
            if (data.FullSyncRequired)
            {
                await ReloadAsync();
                return;
            }
            if (data.Changes.Count == 0)
            {
                var snapshot = await Api.GetQueueAsync();
                if (snapshot.Ok && snapshot.Data != null)
                {
                    if (snapshot.Data.Digest != _queueDigest)
                    {
                        ApplyQueueSnapshot(snapshot.Data);
                    }
                    else
                    {
                        _queueVersion = snapshot.Data.Version;
                        _queueDigest = snapshot.Data.Digest;
                    }
                }
                return;
            }
            ApplyQueueChanges(data);
        }
        finally
        {
            _polling = false;
        }
    }

    private void ApplyQueueChanges(QueueChangesView data)
    {
        if (_view == null)
        {
            return;
        }
        _queueVersion = data.ToVersion;
        if (!string.IsNullOrEmpty(data.QueueViewDigest))
        {
            _queueDigest = data.QueueViewDigest;
        }
        _view.Counters = data.Counters ?? _view.Counters;
        var items = _view.Items;

        foreach (var change in data.Changes)
        {
            switch (change.Type)
            {
                case QueueChangeType.Add:
                case QueueChangeType.Update:
                    if (change.Item == null)
                    {
                        continue;
                    }
                    var existingIndex = items.FindIndex(x => x.Id == change.Item.Id);
                    if (existingIndex >= 0)
                    {
                        items[existingIndex] = change.Item;
                    }
                    else
                    {
                        items.Add(change.Item);
                    }
                    _profileInputs[change.Item.Id] = change.Item.ProfileName ?? "";
                    _priorityInputs[change.Item.Id] = change.Item.Priority;
                    break;
                case QueueChangeType.Remove:
                    if (!change.Id.HasValue)
                    {
                        continue;
                    }
                    var removeIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (removeIndex >= 0)
                    {
                        items.RemoveAt(removeIndex);
                    }
                    _profileInputs.Remove(change.Id.Value);
                    _priorityInputs.Remove(change.Id.Value);
                    break;
                case QueueChangeType.Move:
                    if (!change.Id.HasValue || !change.Position.HasValue)
                    {
                        continue;
                    }
                    var moveIndex = items.FindIndex(x => x.Id == change.Id.Value);
                    if (moveIndex < 0)
                    {
                        continue;
                    }
                    var item = items[moveIndex];
                    items.RemoveAt(moveIndex);
                    var targetIndex = Math.Clamp(change.Position.Value, 0, items.Count);
                    items.Insert(targetIndex, item);
                    break;
            }
        }
        StateHasChanged();
    }

    private void ApplyQueueSnapshot(QueueView snapshot)
    {
        if (_view == null)
        {
            _view = snapshot;
            _queueVersion = snapshot.Version;
            _queueDigest = snapshot.Digest;
            return;
        }
        _queueVersion = snapshot.Version;
        _queueDigest = snapshot.Digest;
        _view.Counters = snapshot.Counters;
        var items = _view.Items;

        var currentMap = items.ToDictionary(item => item.Id, item => item);
        var desired = new List<QueueItemView>(snapshot.Items.Count);
        foreach (var snap in snapshot.Items)
        {
            if (currentMap.TryGetValue(snap.Id, out var current))
            {
                CopyQueueItemView(current, snap);
                desired.Add(current);
            }
            else
            {
                desired.Add(snap);
            }
            _profileInputs[snap.Id] = snap.ProfileName ?? "";
            _priorityInputs[snap.Id] = snap.Priority;
        }
        for (var i = 0; i < desired.Count; i++)
        {
            if (i < items.Count && ReferenceEquals(items[i], desired[i]))
            {
                continue;
            }
            var existingIndex = items.FindIndex(i + 1, x => ReferenceEquals(x, desired[i]));
            if (existingIndex >= 0)
            {
                var moving = items[existingIndex];
                items.RemoveAt(existingIndex);
                items.Insert(i, moving);
            }
            else
            {
                items.Insert(i, desired[i]);
            }
        }
        if (items.Count > desired.Count)
        {
            items.RemoveRange(desired.Count, items.Count - desired.Count);
        }

        var ids = new HashSet<int>(desired.Select(item => item.Id));
        foreach (var id in _profileInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _profileInputs.Remove(id);
        }
        foreach (var id in _priorityInputs.Keys.Where(id => !ids.Contains(id)).ToList())
        {
            _priorityInputs.Remove(id);
        }
        StateHasChanged();
    }

    private static void CopyQueueItemView(QueueItemView target, QueueItemView source)
    {
        target.FileName = source.FileName;
        target.ServiceName = source.ServiceName;
        target.ProfileName = source.ProfileName;
        target.State = source.State;
        target.StateLabel = source.StateLabel;
        target.Priority = source.Priority;
        target.IsBatch = source.IsBatch;
        target.EncodeStart = source.EncodeStart;
        target.EncodeFinish = source.EncodeFinish;
        target.DisplayEncodeStart = source.DisplayEncodeStart;
        target.DisplayEncodeFinish = source.DisplayEncodeFinish;
        target.Progress = source.Progress;
        target.ConsoleId = source.ConsoleId;
        target.OutputMask = source.OutputMask;
        target.IsTooSmall = source.IsTooSmall;
    }


    public async ValueTask DisposeAsync()
    {
        if (_pollCts != null)
        {
            _pollCts.Cancel();
        }
        if (_systemPollCts != null)
        {
            _systemPollCts.Cancel();
        }
        if (_pollTask != null)
        {
            try
            {
                await _pollTask;
            }
            catch (OperationCanceledException)
            {
            }
        }
        if (_systemPollTask != null)
        {
            try
            {
                await _systemPollTask;
            }
            catch (OperationCanceledException)
            {
            }
        }
        _pollCts?.Dispose();
        _systemPollCts?.Dispose();
    }

    private static string? GetProfileName(JsonElement profile)
    {
        if (profile.TryGetProperty("Name", out var nameProp))
        {
            return nameProp.GetString();
        }
        if (profile.TryGetProperty("name", out var namePropLower))
        {
            return namePropLower.GetString();
        }
        return null;
    }

    private static string GetTaskLabel(QueueItemView item)
    {
        switch (item.Mode)
        {
            case ProcMode.Batch:
                return "通常";
            case ProcMode.CMCheck:
                return "CM解析のみ";
            case ProcMode.DrcsCheck:
                return "DRCSチェック";
            case ProcMode.Test:
                return "テスト";
            case ProcMode.AutoBatch:
                return "自動追加";
        }
        return "不明";
    }

    private static string GetBroadcastDateShort(QueueItemView item)
    {
        var timeText = item.DisplayBroadcastTime;
        if (string.IsNullOrEmpty(timeText))
        {
            var time = item.EitStartTime ?? item.TsTime ?? item.EncodeStart;
            timeText = time.HasValue ? time.Value.ToString("MM/dd") : (item.DisplayEncodeStart ?? "-");
        }
        if (string.IsNullOrEmpty(timeText))
        {
            return "-";
        }
        if (DateTime.TryParse(timeText, out var parsed))
        {
            return parsed.ToString("MM/dd");
        }
        if (timeText.Length >= 5 && timeText.Contains('-'))
        {
            var parts = timeText.Split('-', '/', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 3)
            {
                return $"{parts[1]}/{parts[2]}";
            }
        }
        return timeText;
    }

    private static string GetBroadcastChannel(QueueItemView item)
    {
        return string.IsNullOrEmpty(item.ServiceName) ? "-" : item.ServiceName!;
    }

    private static string ToHalfWidth(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }
        var chars = value.ToCharArray();
        for (var i = 0; i < chars.Length; i++)
        {
            var c = chars[i];
            if (c == '\u3000')
            {
                chars[i] = ' ';
                continue;
            }
            if (c >= '\uFF01' && c <= '\uFF5E')
            {
                chars[i] = (char)(c - 0xFEE0);
            }
        }
        return new string(chars);
    }

    private static string GetInputFolder(QueueItemView item)
    {
        var dirPath = item.DirName;
        if (!string.IsNullOrEmpty(dirPath))
        {
            var trimmed = dirPath.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
            var leaf = Path.GetFileName(trimmed);
            return string.IsNullOrEmpty(leaf) ? dirPath : leaf;
        }

        var path = item.SrcPath ?? item.FileName ?? "";
        if (string.IsNullOrEmpty(path))
        {
            return "-";
        }
        var dir = Path.GetDirectoryName(path);
        if (string.IsNullOrEmpty(dir))
        {
            return "-";
        }
        return Path.GetFileName(dir) ?? dir;
    }

    private static string GetInputFile(QueueItemView item)
    {
        var path = item.SrcPath ?? item.FileName ?? "";
        if (string.IsNullOrEmpty(path))
        {
            return "-";
        }
        return Path.GetFileName(path);
    }

    private static string BuildQueueTooltip(QueueItemView item)
    {
        var fullPath = item.SrcPath ?? item.FileName ?? "-";
        var genreText = item.GenreNames == null || item.GenreNames.Count == 0
            ? "-"
            : string.Join(" / ", item.GenreNames);
        var sizeText = (item.ImageWidth > 0 && item.ImageHeight > 0)
            ? $"{item.ImageWidth}x{item.ImageHeight}"
            : "-";
        var tagText = item.Tags == null || item.Tags.Count == 0
            ? "-"
            : string.Join(", ", item.Tags);
        var outDir = string.IsNullOrEmpty(item.OutDir) ? "-" : item.OutDir;

        return $"フルパス: {fullPath}\nジャンル: {genreText}\n映像サイズ: {sizeText}\nタグ: {tagText}\n出力先: {outDir}";
    }
    private static string GetStateText(QueueItemView item)
    {
        var baseText = item.StateLabel ?? item.State ?? "-";
        if (string.Equals(item.State, "Complete", StringComparison.OrdinalIgnoreCase)
            || string.Equals(item.StateLabel, "完了", StringComparison.Ordinal))
        {
            if (item.EncodeStart.HasValue && item.EncodeFinish.HasValue)
            {
                var duration = item.EncodeFinish.Value - item.EncodeStart.Value;
                var finish = item.DisplayEncodeFinish ?? item.EncodeFinish.Value.ToString("yyyy-MM-dd HH:mm");
                return $"{baseText} ({duration:hh\\:mm\\:ss} / {finish})";
            }
        }
        return baseText;
    }

    private async Task CopyProfileAsync(QueueItemView item)
    {
        _actionMessage = null;
        _error = null;
        var targetName = item.ProfileName;
        if (string.IsNullOrWhiteSpace(targetName))
        {
            _error = "Profile name is empty.";
            return;
        }

        var profile = _profiles.FirstOrDefault(p => string.Equals(GetProfileName(p), targetName, StringComparison.OrdinalIgnoreCase));
        if (profile.ValueKind == JsonValueKind.Undefined)
        {
            _error = "Profile not found.";
            return;
        }

        var text = profile.GetRawText();
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            _actionMessage = "Profile copied to clipboard.";
        }
        catch
        {
            _error = "Failed to copy to clipboard.";
        }
    }

    private Task RetryAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ResetState);

    private Task ReapplyProfileAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.UpdateProfile);

    private Task CancelAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.Cancel);

    private Task DeleteAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.RemoveItem);

    private Task ForceStartAsync(QueueItemView item)
        => ChangeItemAsync(item, ChangeItemType.ForceStart);

    private void OpenLogoAnalyze(QueueItemView item)
    {
        var url = $"logo-analyze?queueItemId={item.Id}";
        Nav.NavigateTo(url);
    }

    private async Task ChangePriorityAsync(QueueItemView item)
    {
        if (!_priorityInputs.TryGetValue(item.Id, out var priority))
        {
            priority = item.Priority;
        }
        await ChangeItemAsync(item, ChangeItemType.Priority, priority: priority);
    }

    private async Task ChangeProfileAsync(QueueItemView item)
    {
        if (!_profileInputs.TryGetValue(item.Id, out var profile) || string.IsNullOrWhiteSpace(profile))
        {
            _error = "Profile name is required.";
            return;
        }
        await ChangeItemAsync(item, ChangeItemType.Profile, profile: profile);
    }

    private async Task ChangeItemAsync(QueueItemView item, ChangeItemType type, int? priority = null, string? profile = null, int? position = null)
    {
        var ok = await SendChangeAsync(item.Id, type, priority, profile, position);
        if (ok)
        {
            _actionMessage = "Operation completed.";
            await ReloadAsync();
        }
    }

    private async Task<bool> SendChangeAsync(int itemId, ChangeItemType type, int? priority = null, string? profile = null, int? position = null)
    {
        _actionMessage = null;
        _error = null;
        var req = new ChangeItemData
        {
            ItemId = itemId,
            ChangeType = type,
            Priority = priority ?? 0,
            Profile = profile,
            Position = position ?? 0
        };
        var res = await Api.ChangeQueueAsync(req);
        if (!res.Ok)
        {
            _error = res.Error ?? "Operation failed.";
            return false;
        }
        return true;
    }

    private async Task ExecuteSelectedAsync(ChangeItemType type, string label)
    {
        CloseContextMenu();
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }
        var targets = _view.Items.Where(x => _selectedIds.Contains(x.Id)).ToList();
        if (targets.Count == 0)
        {
            return;
        }
        var anyError = false;
        foreach (var item in targets)
        {
            var ok = await SendChangeAsync(item.Id, type);
            if (!ok)
            {
                anyError = true;
                break;
            }
        }
        if (!anyError)
        {
            _actionMessage = $"{label} を実行しました。";
        }
        await ReloadAsync();
    }

    private void OpenLogoAnalyzeSelectedAsync()
    {
        CloseContextMenu();
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }
        var item = _view.Items.FirstOrDefault(x => _selectedIds.Contains(x.Id));
        if (item == null)
        {
            return;
        }
        OpenLogoAnalyze(item);
    }

    private async Task ClearSucceededAsync()
    {
        CloseContextMenu();
        var ok = await SendChangeAsync(0, ChangeItemType.RemoveCompleted);
        if (ok)
        {
            _actionMessage = "成功済みをクリアしました。";
            await ReloadAsync();
        }
    }

    private void OnRowClick(QueueItemView item, MouseEventArgs e)
    {
        CloseContextMenu();
        if (e.CtrlKey)
        {
            if (_selectedIds.Contains(item.Id))
            {
                _selectedIds.Remove(item.Id);
            }
            else
            {
                _selectedIds.Add(item.Id);
            }
            return;
        }
        if (_selectedIds.Contains(item.Id))
        {
            return;
        }
        _selectedIds.Clear();
        _selectedIds.Add(item.Id);
    }

    private void OnRowContextMenu(QueueItemView item, MouseEventArgs e)
    {
        if (!_selectedIds.Contains(item.Id))
        {
            _selectedIds.Clear();
            _selectedIds.Add(item.Id);
        }
        _contextMenuX = e.ClientX;
        _contextMenuY = e.ClientY;
        _contextMenuVisible = true;
    }

    private void OpenConsoleSelected()
    {
        if (_selectedIds.Count == 0)
        {
            return;
        }
        var taskId = _selectedIds.First();
        CloseContextMenu();
        Nav.NavigateTo($"/console/{taskId}");
    }

    private void CloseContextMenu()
    {
        _contextMenuVisible = false;
    }

    private string GetRowClass(QueueItemView item, int rowIndex)
    {
        var classes = new List<string> { "queue-row", GetStateClass(item) };
        if (_selectedIds.Contains(item.Id))
        {
            classes.Add("is-selected");
            if (_isDragging)
            {
                classes.Add("is-dragging");
            }
        }
        if (_dropIndex == rowIndex)
        {
            classes.Add("queue-drop-target");
        }
        return string.Join(" ", classes.Where(c => !string.IsNullOrWhiteSpace(c)));
    }

    private static string GetStateClass(QueueItemView item)
    {
        var state = item.State ?? string.Empty;
        if (string.IsNullOrWhiteSpace(state))
        {
            state = item.StateLabel ?? string.Empty;
        }
        if (state.Equals("Encoding", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-encoding";
        }
        if (state.Equals("Failed", StringComparison.OrdinalIgnoreCase) || state.Equals("PreFailed", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-error";
        }
        if (state.Equals("Queue", StringComparison.OrdinalIgnoreCase) || state.Equals("LogoPending", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-pending";
        }
        if (state.Equals("Canceled", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-canceled";
        }
        if (state.Equals("Complete", StringComparison.OrdinalIgnoreCase))
        {
            return "queue-state-complete";
        }
        if (state.Contains("エンコード", StringComparison.Ordinal))
        {
            return "queue-state-encoding";
        }
        if (state.Contains("失敗", StringComparison.Ordinal))
        {
            return "queue-state-error";
        }
        if (state.Contains("ペンディング", StringComparison.Ordinal) || state.Contains("待ち", StringComparison.Ordinal))
        {
            return "queue-state-pending";
        }
        if (state.Contains("キャンセル", StringComparison.Ordinal))
        {
            return "queue-state-canceled";
        }
        if (state.Contains("完了", StringComparison.Ordinal))
        {
            return "queue-state-complete";
        }
        return string.Empty;
    }

    private async Task MoveSelectedItemsAsync(int dropIndex)
    {
        if (_view == null || _selectedIds.Count == 0)
        {
            return;
        }

        var selectedIds = _view.Items
            .Where(item => _selectedIds.Contains(item.Id))
            .Select(item => item.Id)
            .ToList();

        if (selectedIds.Count == 0)
        {
            return;
        }

        _actionMessage = null;
        _error = null;

        var req = new QueueMoveManyRequest
        {
            ItemIds = selectedIds,
            DropIndex = dropIndex
        };

        var res = await Api.MoveQueueManyAsync(req);
        if (!res.Ok)
        {
            _error = res.Error ?? "Operation failed.";
            return;
        }

        await ReloadAsync();
    }

    private async Task OnQueueDrop(int index)
    {
        if (_view == null)
        {
            return;
        }
        _dropIndex = -1;
        var fromIndex = await JS.InvokeAsync<int>("amatsukazeDnd.getDragIndex");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearDragIndex");
        if (fromIndex < 0)
        {
            return;
        }

        // ドラッグ元アイテムを選択に含める
        var draggedItem = _view.Items[fromIndex];
        if (!_selectedIds.Contains(draggedItem.Id))
        {
            _selectedIds.Clear();
            _selectedIds.Add(draggedItem.Id);
        }

        // 複数選択の場合
        if (_selectedIds.Count > 1)
        {
            await MoveSelectedItemsAsync(index);
            return;
        }

        // 単一選択の場合（従来の処理）
        if (fromIndex == index)
        {
            return;
        }
        var toIndex = index;
        if (toIndex > fromIndex)
        {
            toIndex -= 1;
        }
        if (toIndex < 0)
        {
            toIndex = 0;
        }
        if (toIndex >= _view.Items.Count)
        {
            toIndex = _view.Items.Count - 1;
        }
        await ChangeItemAsync(draggedItem, ChangeItemType.Move, position: toIndex);
    }

    private Task OnQueueDropFromBody()
    {
        return Task.CompletedTask;
    }

    private void OnQueueDragEnter(int index)
    {
        _dropIndex = index;
        _isDragging = true;
    }

    private void OnQueueBodyDragEnter()
    {
        if (_view == null)
        {
            return;
        }
        if (_dropIndex < 0)
        {
            _dropIndex = _view.Items.Count;
        }
    }

    private async Task OnQueueDragEnd()
    {
        _isDragging = false;
        var lastDropIndex = await JS.InvokeAsync<int>("amatsukazeDnd.getLastDropIndex");
        await JS.InvokeVoidAsync("amatsukazeDnd.clearLastDropIndex");
        if (_view == null)
        {
            _dropIndex = -1;
            await JS.InvokeVoidAsync("amatsukazeDnd.clearDragIndex");
            return;
        }
        if (lastDropIndex == -2)
        {
            lastDropIndex = _view.Items.Count;
        }
        if (lastDropIndex >= 0)
        {
            await OnQueueDrop(lastDropIndex);
        }
        _dropIndex = -1;
        await JS.InvokeVoidAsync("amatsukazeDnd.clearDragIndex");
    }


    private string GetDropRowClass()
        => _dropIndex == (_view?.Items.Count ?? -1) ? "queue-drop-row queue-drop-target" : "queue-drop-row";

    private async Task OnToggleQueuePause(ChangeEventArgs e)
    {
        if (_system?.State == null || _pauseBusy)
        {
            return;
        }
        _pauseBusy = true;
        var desiredRunning = GetBoolValue(e.Value);
        var req = new PauseRequest
        {
            IsQueue = true,
            Pause = !desiredRunning
        };
        var res = await Api.PauseQueueAsync(req);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _pauseBusy = false;
    }

    private async Task OnToggleEncoderSuspend(ChangeEventArgs e)
    {
        if (_system?.State == null || _suspendBusy)
        {
            return;
        }
        _suspendBusy = true;
        var desiredOk = GetBoolValue(e.Value);
        var req = new PauseRequest
        {
            IsQueue = false,
            Index = -1,
            Pause = !desiredOk
        };
        var res = await Api.PauseQueueAsync(req);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _suspendBusy = false;
    }

    private async Task OnFinishActionChanged(ChangeEventArgs e)
    {
        if (_system?.FinishSetting == null || _finishBusy)
        {
            return;
        }
        var value = e.Value?.ToString() ?? "";
        if (string.IsNullOrWhiteSpace(value) || value == _system.FinishSetting.Action)
        {
            return;
        }
        _finishBusy = true;
        var setting = new FinishSetting
        {
            Action = value,
            Seconds = _system.FinishSetting.Seconds,
            NoActionExe = _system.FinishSetting.NoActionExe,
            NoActionExeList = _system.FinishSetting.NoActionExeList != null
                ? new List<string>(_system.FinishSetting.NoActionExeList)
                : null
        };
        var res = await Api.UpdateFinishSettingAsync(setting);
        if (!res.Ok)
        {
            _systemError = res.Error ?? "Failed to update.";
        }
        await ReloadSystemAsync();
        _finishBusy = false;
    }

    private static bool GetBoolValue(object? value)
    {
        if (value is bool b)
        {
            return b;
        }
        if (value is string s && bool.TryParse(s, out var parsed))
        {
            return parsed;
        }
        return false;
    }
}
