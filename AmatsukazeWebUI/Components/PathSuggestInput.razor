@using System.Threading
@using Amatsukaze.Shared
@inject IAmatsukazeApi Api
@inject IJSRuntime Js

<div class="path-suggest-input">
    <input value="@Value"
           placeholder="@Placeholder"
           disabled="@Disabled"
           @oninput="OnInputAsync"
           @onkeydown="OnKeyDownAsync"
           @onfocus="OnFocus"
           @onblur="OnBlurAsync" />
@if (_showSuggestions)
{
    <div class="path-suggest-list" @ref="_listRef" @onmouseenter="OnListEnter" @onmouseleave="OnListLeave">
        @if (_dirs.Count > 0)
        {
            <div class="path-suggest-group">Folders</div>
            @for (var i = 0; i < _dirs.Count; i++)
            {
                    var index = i;
                    var itemIndex = index;
                    <div class="path-suggest-item @GetSelectedClass(itemIndex)"
                         @onmousedown="() => Select(_dirs[index].FullPath)">
                        [DIR] @_dirs[index].Name
                </div>
            }
            @if (_hasMoreDirs)
            {
                <div class="path-suggest-more" @onmousedown="LoadMoreDirs" @onmousedown:preventDefault="true">
                    続きを読み込む (フォルダ)
                </div>
            }
        }
        @if (_files.Count > 0)
        {
            <div class="path-suggest-group">Files</div>
            @for (var i = 0; i < _files.Count; i++)
            {
                    var index = i;
                    var itemIndex = _dirs.Count + index;
                    <div class="path-suggest-item @GetSelectedClass(itemIndex)"
                         @onmousedown="() => Select(_files[index].FullPath)">
                        [FILE] @_files[index].Name
                </div>
            }
            @if (_hasMoreFiles)
            {
                <div class="path-suggest-more" @onmousedown="LoadMoreFiles" @onmousedown:preventDefault="true">
                    続きを読み込む (ファイル)
                </div>
            }
        }
        @if (!string.IsNullOrEmpty(_error))
        {
            <div class="path-suggest-error">@_error</div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public string Value { get; set; } = "";
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public string? Extensions { get; set; }
    [Parameter] public bool AllowFiles { get; set; } = true;
    [Parameter] public bool AllowDirs { get; set; } = true;
    [Parameter] public bool CheckAccess { get; set; } = false;
    [Parameter] public int MaxDirs { get; set; } = 10;
    [Parameter] public int MaxFiles { get; set; } = 20;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string? Placeholder { get; set; }

    private readonly List<PathCandidate> _dirs = new();
    private readonly List<PathCandidate> _files = new();
    private bool _showSuggestions;
    private string? _error;
    private CancellationTokenSource? _cts;
    private int _selectedIndex = -1;
    private bool _hovering;
    private bool _focused;
    private ElementReference _listRef;
    private int _dirOffset;
    private int _fileOffset;
    private bool _hasMoreDirs;
    private bool _hasMoreFiles;
    private bool _loadingMore;
    private double _pendingScrollTop;

    private async Task OnInputAsync(ChangeEventArgs e)
    {
        if (Disabled)
        {
            return;
        }
        var value = e.Value?.ToString() ?? "";
        await ValueChanged.InvokeAsync(value);

        _cts?.Cancel();
        _cts?.Dispose();
        _cts = new CancellationTokenSource();
        var token = _cts.Token;

        if (string.IsNullOrWhiteSpace(value))
        {
            ClearSuggestions();
            return;
        }
        _dirOffset = 0;
        _fileOffset = 0;
        _hasMoreDirs = false;
        _hasMoreFiles = false;

        try
        {
            await Task.Delay(200, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        if (token.IsCancellationRequested)
        {
            return;
        }

        await FetchSuggestionsAsync(value, append: false);
    }

    private void OnFocus()
    {
        _focused = true;
        if (_dirs.Count > 0 || _files.Count > 0 || !string.IsNullOrEmpty(_error))
        {
            _showSuggestions = true;
        }
    }

    private async Task OnBlurAsync()
    {
        _focused = false;
        await Task.Delay(100);
        if (!_hovering && !_focused)
        {
            _showSuggestions = false;
        }
    }

    private void OnListEnter()
    {
        _hovering = true;
    }

    private void OnListLeave()
    {
        _hovering = false;
        if (!_focused)
        {
            _showSuggestions = false;
        }
    }

    private async Task FetchSuggestionsAsync(string input, bool append)
    {
        _error = null;
        _loadingMore = append;
        var req = new PathSuggestRequest
        {
            Input = input,
            Extensions = Extensions,
            AllowDirs = AllowDirs,
            AllowFiles = AllowFiles,
            MaxDirs = MaxDirs,
            MaxFiles = MaxFiles,
            CheckAccess = CheckAccess,
            DirOffset = append ? _dirOffset : 0,
            FileOffset = append ? _fileOffset : 0
        };

        var res = await Api.GetPathSuggestAsync(req);
        if (!res.Ok || res.Data == null)
        {
            _dirs.Clear();
            _files.Clear();
            _showSuggestions = false;
            _error = res.Error ?? "Failed to load suggestions.";
            _loadingMore = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        if (!append)
        {
            _dirs.Clear();
            _files.Clear();
        }
        _dirs.AddRange(res.Data.Dirs ?? new List<PathCandidate>());
        _files.AddRange(res.Data.Files ?? new List<PathCandidate>());
        _hasMoreDirs = res.Data.HasMoreDirs;
        _hasMoreFiles = res.Data.HasMoreFiles;
        _dirOffset = res.Data.NextDirOffset;
        _fileOffset = res.Data.NextFileOffset;
        _showSuggestions = (_dirs.Count > 0 || _files.Count > 0 || !string.IsNullOrEmpty(_error)) && _focused;
        if (!append)
        {
            _selectedIndex = _showSuggestions ? 0 : -1;
        }
        _loadingMore = false;
        await InvokeAsync(StateHasChanged);
        if (append)
        {
            await RestoreScrollTopAsync();
        }
        else
        {
            await EnsureSelectedVisibleAsync();
        }
    }

    private async Task Select(string value)
    {
        await ValueChanged.InvokeAsync(value);
        ClearSuggestions();
    }

    private void ClearSuggestions()
    {
        _dirs.Clear();
        _files.Clear();
        _showSuggestions = false;
        _error = null;
        _selectedIndex = -1;
        _dirOffset = 0;
        _fileOffset = 0;
        _hasMoreDirs = false;
        _hasMoreFiles = false;
        _loadingMore = false;
        InvokeAsync(StateHasChanged);
    }

    private string GetSelectedClass(int index)
    {
        return index == _selectedIndex ? "is-selected" : string.Empty;
    }

    private Task OnKeyDownAsync(KeyboardEventArgs e)
    {
        if (!_showSuggestions)
        {
            if (e.Key == "ArrowDown" || e.Key == "ArrowUp")
            {
                _showSuggestions = _dirs.Count > 0 || _files.Count > 0;
                _selectedIndex = _showSuggestions ? 0 : -1;
                StateHasChanged();
            }
            return Task.CompletedTask;
        }

        var total = _dirs.Count + _files.Count;
        if (total == 0)
        {
            return Task.CompletedTask;
        }

        if (e.Key == "ArrowDown")
        {
            _selectedIndex = Math.Min(_selectedIndex + 1, total - 1);
            StateHasChanged();
            _ = EnsureSelectedVisibleAsync();
        }
        else if (e.Key == "ArrowUp")
        {
            _selectedIndex = Math.Max(_selectedIndex - 1, 0);
            StateHasChanged();
            _ = EnsureSelectedVisibleAsync();
        }
        else if (e.Key == "Enter")
        {
            var selected = GetSelectedCandidate();
            if (selected != null)
            {
                return Select(selected);
            }
        }
        else if (e.Key == "Escape")
        {
            _showSuggestions = false;
            _selectedIndex = -1;
            StateHasChanged();
        }

        return Task.CompletedTask;
    }

    private async Task EnsureSelectedVisibleAsync()
    {
        if (!_showSuggestions || _selectedIndex < 0)
        {
            return;
        }
        try
        {
            await Task.Yield();
            await Js.InvokeVoidAsync("amatsukazeUi.ensureListItemVisible", _listRef, _selectedIndex);
        }
        catch
        {
            // best-effort only
        }
    }

    private string? GetSelectedCandidate()
    {
        if (_selectedIndex < 0)
        {
            return null;
        }
        if (_selectedIndex < _dirs.Count)
        {
            return _dirs[_selectedIndex].FullPath;
        }
        var fileIndex = _selectedIndex - _dirs.Count;
        if (fileIndex >= 0 && fileIndex < _files.Count)
        {
            return _files[fileIndex].FullPath;
        }
        return null;
    }

    private async Task LoadMoreDirs()
    {
        if (_loadingMore || !_hasMoreDirs)
        {
            return;
        }
        _hovering = true;
        _pendingScrollTop = await GetScrollTopAsync();
        await FetchSuggestionsAsync(Value, append: true);
    }

    private async Task LoadMoreFiles()
    {
        if (_loadingMore || !_hasMoreFiles)
        {
            return;
        }
        _hovering = true;
        _pendingScrollTop = await GetScrollTopAsync();
        await FetchSuggestionsAsync(Value, append: true);
    }

    private async Task<double> GetScrollTopAsync()
    {
        try
        {
            return await Js.InvokeAsync<double>("amatsukazeUi.getScrollTop", _listRef);
        }
        catch
        {
            return 0;
        }
    }

    private async Task RestoreScrollTopAsync()
    {
        try
        {
            await Js.InvokeVoidAsync("amatsukazeUi.setScrollTop", _listRef, _pendingScrollTop);
        }
        catch
        {
        }
    }
}
