@using Amatsukaze.Shared
@inject IAmatsukazeApi Api
@implements IDisposable

<div class="message-topbar" role="status">
    <div class="message-topbar-title">
        <span class="message-topbar-icon" aria-hidden="true">ğŸ””</span>
        <span>é€šçŸ¥</span>
    </div>
    <div class="message-topbar-list">
        @if (items.Count == 0)
        {
            <div class="message-item message-muted">
                <span class="message-text">ãªã—</span>
            </div>
        }
        else
        {
            @foreach (var item in items.OrderByDescending(i => i.Id))
            {
                var isExpired = IsExpired(item);
                var isNewest = item.Id == latestId;
                <div class="message-item message-@item.Level @(isNewest ? "message-new" : "") @(isExpired ? "message-expired" : "")">
                    <span class="message-time">@item.Time.ToLocalTime().ToString("HH:mm:ss")</span>
                    <span class="message-text">@item.Message</span>
                </div>
            }
        }
    </div>
</div>

@code {
    [Parameter] public string? Page { get; set; }

    private readonly List<MessageEventView> items = new();
    private long lastId;
    private long latestId;
    private string? currentPage;
    private CancellationTokenSource? cts;
    private PeriodicTimer? timer;
    private readonly SemaphoreSlim pollLock = new(1, 1);

    protected override async Task OnParametersSetAsync()
    {
        if (string.Equals(currentPage, Page, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        currentPage = Page;
        lastId = 0;
        items.Clear();
        RestartPolling();
        await PollOnceAsync();
    }

    private void RestartPolling()
    {
        cts?.Cancel();
        cts?.Dispose();
        timer?.Dispose();
        cts = new CancellationTokenSource();
        timer = new PeriodicTimer(TimeSpan.FromSeconds(2));
        _ = PollLoopAsync(cts.Token);
    }

    private async Task PollLoopAsync(CancellationToken token)
    {
        try
        {
            while (await timer!.WaitForNextTickAsync(token))
            {
                await PollOnceAsync();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            // ignore
        }
    }

    private async Task PollOnceAsync()
    {
        if (string.IsNullOrWhiteSpace(currentPage))
        {
            return;
        }

        if (!await pollLock.WaitAsync(0))
        {
            return;
        }

        try
        {
            var result = await Api.GetMessageChangesAsync(lastId, currentPage, null, "info,warn,error", 20);
            if (!result.Ok || result.Data == null)
            {
                return;
            }

            var view = result.Data;
            if (view.FullSyncRequired)
            {
                items.Clear();
            }
            if (view.Items != null && view.Items.Count > 0)
            {
                items.AddRange(view.Items);
                while (items.Count > 2)
                {
                    items.RemoveAt(0);
                }
                latestId = items.Count > 0 ? items.Max(i => i.Id) : 0;
            }
            lastId = view.ToId;
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            pollLock.Release();
        }
    }

    private static bool IsExpired(MessageEventView item)
    {
        var now = DateTime.UtcNow;
        var itemTime = item.Time.Kind == DateTimeKind.Utc
            ? item.Time
            : item.Time.ToUniversalTime();
        return (now - itemTime) >= TimeSpan.FromMinutes(5);
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
        timer?.Dispose();
        pollLock.Dispose();
    }

}
