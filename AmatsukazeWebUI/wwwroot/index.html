<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AmatsukazeWebUI</title>
    <base href="/" />
    <link rel="stylesheet" href="lib/bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="AmatsukazeWebUI.styles.css" rel="stylesheet" />
</head>

<body>
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="." class="reload">Reload</a>
        <span class="dismiss">ðŸ—™</span>
    </div>
    <script src="_framework/blazor.webassembly.js"></script>
    <script>
        window.amatsukazeDnd = {
            lastDropIndex: -1,
            lastDropId: -999,
            dragId: -1,
            setData: function (event) {
                try {
                    if (event && event.dataTransfer) {
                        event.dataTransfer.setData("text/plain", "dnd");
                        event.dataTransfer.effectAllowed = "move";
                        event.dataTransfer.dropEffect = "move";
                        return true;
                    }
                } catch (e) {
                }
                return true;
            },
            setDataWithQueueId: function (event) {
                try {
                    if (event && event.currentTarget && event.currentTarget.dataset) {
                        var id = event.currentTarget.dataset.queueId;
                        if (id !== undefined) {
                            window.amatsukazeDnd.dragId = parseInt(id, 10);
                        }
                    }
                } catch (e) {
                }
                return window.amatsukazeDnd.setData(event);
            },
            setDataWithIndex: function (event) {
                try {
                    if (event && event.currentTarget && event.currentTarget.dataset) {
                        var index = event.currentTarget.dataset.queueIndex;
                        if (index !== undefined) {
                            window.amatsukazeDnd.dragIndex = parseInt(index, 10);
                        }
                    }
                } catch (e) {
                }
                return window.amatsukazeDnd.setData(event);
            },
            getDragId: function () {
                if (typeof window.amatsukazeDnd.dragId === "number" && !isNaN(window.amatsukazeDnd.dragId)) {
                    return window.amatsukazeDnd.dragId;
                }
                return -1;
            },
            clearDragId: function () {
                window.amatsukazeDnd.dragId = -1;
            },
            getDragIndexFromEvent: function (event) {
                try {
                    if (event && event.currentTarget && event.currentTarget.dataset) {
                        var index = event.currentTarget.dataset.queueIndex;
                        if (index !== undefined) {
                            var parsed = parseInt(index, 10);
                            if (!isNaN(parsed)) {
                                return parsed;
                            }
                        }
                    }
                } catch (e) {
                }
                return -1;
            },
            getDragIndex: function () {
                if (typeof window.amatsukazeDnd.dragIndex === "number" && !isNaN(window.amatsukazeDnd.dragIndex)) {
                    return window.amatsukazeDnd.dragIndex;
                }
                return -1;
            },
            setLastDropIndex: function (event) {
                try {
                    if (event && event.currentTarget && event.currentTarget.dataset) {
                        if (event.currentTarget.dataset.queueIndex !== undefined) {
                            var index = parseInt(event.currentTarget.dataset.queueIndex, 10);
                            if (!isNaN(index)) {
                                window.amatsukazeDnd.lastDropIndex = index;
                                return;
                            }
                        }
                        if (event.currentTarget.dataset.dropEnd === "true") {
                            window.amatsukazeDnd.lastDropIndex = -2;
                            return;
                        }
                    }
                } catch (e) {
                }
            },
            setLastDropId: function (event) {
                try {
                    if (event && event.currentTarget && event.currentTarget.dataset) {
                        if (event.currentTarget.dataset.queueId !== undefined) {
                            var id = parseInt(event.currentTarget.dataset.queueId, 10);
                            if (!isNaN(id)) {
                                window.amatsukazeDnd.lastDropId = id;
                                return;
                            }
                        }
                        if (event.currentTarget.dataset.dropEnd === "true") {
                            var prev = event.currentTarget.previousElementSibling;
                            while (prev && (!prev.dataset || prev.dataset.queueId === undefined)) {
                                prev = prev.previousElementSibling;
                            }
                            if (prev && prev.dataset && prev.dataset.queueId !== undefined) {
                                var prevId = parseInt(prev.dataset.queueId, 10);
                                if (!isNaN(prevId)) {
                                    window.amatsukazeDnd.lastDropId = prevId;
                                    return;
                                }
                            }
                            window.amatsukazeDnd.lastDropId = -1;
                            return;
                        }
                    }
                } catch (e) {
                }
            },
            getLastDropIndex: function () {
                return typeof window.amatsukazeDnd.lastDropIndex === "number"
                    ? window.amatsukazeDnd.lastDropIndex
                    : -1;
            },
            getLastDropId: function () {
                return typeof window.amatsukazeDnd.lastDropId === "number"
                    ? window.amatsukazeDnd.lastDropId
                    : -999;
            },
            clearLastDropIndex: function () {
                window.amatsukazeDnd.lastDropIndex = -1;
            },
            clearLastDropId: function () {
                window.amatsukazeDnd.lastDropId = -999;
            },
            clearDragIndex: function () {
                window.amatsukazeDnd.dragIndex = -1;
            },
            setDragIndex: function (index) {
                window.amatsukazeDnd.dragIndex = index;
            },
            onEnter: function (event) {
                try {
                    if (event && event.dataTransfer) {
                        event.preventDefault();
                        return true;
                    }
                } catch (e) {
                }
                return true;
            },
            onOver: function (event) {
                try {
                    if (event && event.dataTransfer) {
                        event.preventDefault();
                        return true;
                    }
                } catch (e) {
                }
                return true;
            }
            ,
            onOverWithIndex: function (event) {
                try {
                    window.amatsukazeDnd.setLastDropIndex(event);
                    if (event && event.dataTransfer) {
                        event.preventDefault();
                        return true;
                    }
                } catch (e) {
                }
                return true;
            },
            onOverWithId: function (event) {
                try {
                    window.amatsukazeDnd.setLastDropId(event);
                    if (event && event.dataTransfer) {
                        event.preventDefault();
                        return true;
                    }
                } catch (e) {
                }
                return true;
            },
            updateDropIndexFromEvent: function (event) {
                try {
                    if (!event) {
                        return true;
                    }
                    if (event.clientX !== undefined && event.clientY !== undefined) {
                        var el = document.elementFromPoint(event.clientX, event.clientY);
                        if (el) {
                            var row = el.closest("tr[data-queue-index]");
                            if (row && row.dataset && row.dataset.queueIndex !== undefined) {
                                var idx = parseInt(row.dataset.queueIndex, 10);
                                if (!isNaN(idx)) {
                                    window.amatsukazeDnd.lastDropIndex = idx;
                                    return true;
                                }
                            }
                            var end = el.closest("[data-drop-end=\"true\"]");
                            if (end) {
                                window.amatsukazeDnd.lastDropIndex = -2;
                            }
                        }
                    }
                } catch (e) {
                }
                return true;
            },
            updateDropIdFromEvent: function (event) {
                try {
                    if (!event) {
                        return true;
                    }
                    if (event.clientX !== undefined && event.clientY !== undefined) {
                        var el = document.elementFromPoint(event.clientX, event.clientY);
                        if (el) {
                            var row = el.closest("tr[data-queue-id]");
                            if (row && row.dataset && row.dataset.queueId !== undefined) {
                                var rect = row.getBoundingClientRect();
                                var usePrev = event.clientY <= rect.top + rect.height / 2;
                                var target = row;
                                if (usePrev) {
                                    var prev = row.previousElementSibling;
                                    while (prev && (!prev.dataset || prev.dataset.queueId === undefined)) {
                                        prev = prev.previousElementSibling;
                                    }
                                    if (prev) {
                                        target = prev;
                                    } else {
                                        window.amatsukazeDnd.lastDropId = -1;
                                        return true;
                                    }
                                }
                                var id = parseInt(target.dataset.queueId, 10);
                                if (!isNaN(id)) {
                                    window.amatsukazeDnd.lastDropId = id;
                                    return true;
                                }
                            }
                            var end = el.closest("[data-drop-end=\"true\"]");
                            if (end) {
                                var prev = end.previousElementSibling;
                                while (prev && (!prev.dataset || prev.dataset.queueId === undefined)) {
                                    prev = prev.previousElementSibling;
                                }
                                if (prev && prev.dataset && prev.dataset.queueId !== undefined) {
                                    var prevId = parseInt(prev.dataset.queueId, 10);
                                    if (!isNaN(prevId)) {
                                        window.amatsukazeDnd.lastDropId = prevId;
                                        return true;
                                    }
                                }
                                window.amatsukazeDnd.lastDropId = -1;
                            }
                        }
                    }
                } catch (e) {
                }
                return true;
            }
        };
        window.amatsukazeUi = {
            getScrollInfo: function (element) {
                try {
                    if (!element) {
                        return { scrollTop: 0, scrollHeight: 0, clientHeight: 0, remaining: 0 };
                    }
                    var scrollTop = element.scrollTop || 0;
                    var scrollHeight = element.scrollHeight || 0;
                    var clientHeight = element.clientHeight || 0;
                    var remaining = scrollHeight - scrollTop - clientHeight;
                    return {
                        scrollTop: scrollTop,
                        scrollHeight: scrollHeight,
                        clientHeight: clientHeight,
                        remaining: remaining
                    };
                } catch (e) {
                    return { scrollTop: 0, scrollHeight: 0, clientHeight: 0, remaining: 0 };
                }
            },
            ensureListItemVisible: function (listEl, index) {
                try {
                    if (!listEl || typeof index !== "number") {
                        return;
                    }
                    var items = listEl.querySelectorAll(".path-suggest-item");
                    if (!items || index < 0 || index >= items.length) {
                        return;
                    }
                    var item = items[index];
                    var top = item.offsetTop;
                    var bottom = top + item.offsetHeight;
                    var viewTop = listEl.scrollTop;
                    var viewBottom = viewTop + listEl.clientHeight;
                    if (top < viewTop) {
                        listEl.scrollTop = top;
                    } else if (bottom > viewBottom) {
                        listEl.scrollTop = bottom - listEl.clientHeight;
                    }
                } catch (e) {
                }
            },
            getScrollTop: function (listEl) {
                try {
                    if (!listEl) {
                        return 0;
                    }
                    return listEl.scrollTop || 0;
                } catch (e) {
                    return 0;
                }
            },
            setScrollTop: function (listEl, top) {
                try {
                    if (!listEl || typeof top !== "number") {
                        return;
                    }
                    listEl.scrollTop = top;
                } catch (e) {
                }
            }
        };
    </script>
</body>

</html>
